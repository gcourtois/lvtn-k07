//
// Generated by JTB 1.3.2
//
package com.res.cobol.visitor;

import java.util.Enumeration;
import java.util.Vector;

import com.res.cobol.syntaxtree.*;

/**
 * A skeleton output formatter for your language grammar. Using the add() method
 * along with force(), indent(), and outdent(), you can easily specify how this
 * visitor will format the given syntax tree. See the JTB documentation for more
 * details.
 * 
 * Pass your syntax tree to this visitor, and then to the TreeDumper visitor in
 * order to "pretty print" your tree.
 */
public class TreeFormatter extends DepthFirstVisitor {
    private Vector<FormatCommand> cmdQueue = new Vector<FormatCommand>();
    private boolean lineWrap;
    private int wrapWidth;
    private int indentAmt;
    private int curLine = 1;
    private int curColumn = 1;
    private int curIndent = 0;

    /**
     * The default constructor assumes an indentation amount of 3 spaces and no
     * line-wrap. You may alternately use the other constructor to specify your
     * own indentation amount and line width.
     */
    public TreeFormatter() {
        this(3, 0);
    }

    /**
     * This constructor accepts an indent amount and a line width which is used
     * to wrap long lines. If a token's beginColumn value is greater than the
     * specified wrapWidth, it will be moved to the next line and indented one
     * extra level. To turn off line-wrapping, specify a wrapWidth of 0.
     * 
     * @param indentAmt
     *            Amount of spaces per indentation level.
     * @param wrapWidth
     *            Wrap lines longer than wrapWidth. 0 for no wrap.
     */
    public TreeFormatter(int indentAmt, int wrapWidth) {
        this.indentAmt = indentAmt;
        this.wrapWidth = wrapWidth;

        if (wrapWidth > 0)
            lineWrap = true;
        else
            lineWrap = false;
    }

    /**
     * Accepts a NodeListInterface object and performs an optional format
     * command between each node in the list (but not after the last node).
     * 
     * @throws Exception
     */
    protected void processList(NodeListInterface n) throws Exception {
        processList(n, null);
    }

    protected void processList(NodeListInterface n, FormatCommand cmd)
            throws Exception {
        for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
            e.nextElement().accept(this);
            if (cmd != null && e.hasMoreElements())
                cmdQueue.addElement(cmd);
        }
    }

    /**
     * A Force command inserts a line break and indents the next line to the
     * current indentation level. Use "add(force());".
     */
    protected FormatCommand force() {
        return force(1);
    }

    protected FormatCommand force(int i) {
        return new FormatCommand(FormatCommand.FORCE, i);
    }

    /**
     * An Indent command increases the indentation level by one (or a
     * user-specified amount). Use "add(indent());".
     */
    protected FormatCommand indent() {
        return indent(1);
    }

    protected FormatCommand indent(int i) {
        return new FormatCommand(FormatCommand.INDENT, i);
    }

    /**
     * An Outdent command is the reverse of the Indent command: it reduces the
     * indentation level. Use "add(outdent());".
     */
    protected FormatCommand outdent() {
        return outdent(1);
    }

    protected FormatCommand outdent(int i) {
        return new FormatCommand(FormatCommand.OUTDENT, i);
    }

    /**
     * A Space command simply adds one or a user-specified number of spaces
     * between tokens. Use "add(space());".
     */
    protected FormatCommand space() {
        return space(1);
    }

    protected FormatCommand space(int i) {
        return new FormatCommand(FormatCommand.SPACE, i);
    }

    /**
     * Use this method to add FormatCommands to the command queue to be executed
     * when the next token in the tree is visited.
     */
    protected void add(FormatCommand cmd) {
        cmdQueue.addElement(cmd);
    }

    /**
     * Executes the commands waiting in the command queue, then inserts the
     * proper location information into the current NodeToken.
     * 
     * If there are any special tokens preceding this token, they will be given
     * the current location information. The token will follow on the next line,
     * at the proper indentation level. If this is not the behavior you want
     * from special tokens, feel free to modify this method.
     */
    public void visit(NodeToken n) throws Exception {
        for (Enumeration<FormatCommand> e = cmdQueue.elements(); e
                .hasMoreElements();) {
            FormatCommand cmd = e.nextElement();
            switch (cmd.getCommand()) {
            case FormatCommand.FORCE:
                curLine += cmd.getNumCommands();
                curColumn = curIndent + 1;
                break;
            case FormatCommand.INDENT:
                curIndent += indentAmt * cmd.getNumCommands();
                break;
            case FormatCommand.OUTDENT:
                if (curIndent >= indentAmt)
                    curIndent -= indentAmt * cmd.getNumCommands();
                break;
            case FormatCommand.SPACE:
                curColumn += cmd.getNumCommands();
                break;
            default:
                throw new TreeFormatterException(
                        "Invalid value in command queue.");
            }
        }

        cmdQueue.removeAllElements();

        //
        // Handle all special tokens preceding this NodeToken
        //
        if (n.numSpecials() > 0)
            for (Enumeration<NodeToken> e = n.specialTokens.elements(); e
                    .hasMoreElements();) {
                NodeToken special = e.nextElement();

                //
                // -Place the token.
                // -Move cursor to next line after the special token.
                // -Don't update curColumn--want to keep current indent level.
                //
                placeToken(special, curLine, curColumn);
                curLine = special.endLine + 1;
            }

        placeToken(n, curLine, curColumn);
        curLine = n.endLine;
        curColumn = n.endColumn;
    }

    /**
     * Inserts token location (beginLine, beginColumn, endLine, endColumn)
     * information into the NodeToken. Takes into account line-wrap. Does not
     * update curLine and curColumn.
     */
    private void placeToken(NodeToken n, int line, int column) throws Exception {
        int length = n.tokenImage.length();

        //
        // Find beginning of token. Only line-wrap for single-line tokens
        //
        if (!lineWrap || n.tokenImage.indexOf('\n') != -1
                || column + length <= wrapWidth)
            n.beginColumn = column;
        else {
            ++line;
            column = curIndent + indentAmt + 1;
            n.beginColumn = column;
        }

        n.beginLine = line;

        //
        // Find end of token; don't count \n if it's the last character
        //
        for (int i = 0; i < length; ++i) {
            if (n.tokenImage.charAt(i) == '\n' && i < length - 1) {
                ++line;
                column = 1;
            } else
                ++column;
        }

        n.endLine = line;
        n.endColumn = column;
    }

    //
    // User-generated visitor methods below
    //

    /**
     * <PRE>
     * nodeToken -&gt; &lt;COBOL_WORD&gt;
     * </PRE>
     */
    public void visit(CobolWord n) throws Exception {
        n.nodeToken.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; &lt;LEVEL_66&gt;
     *       | &lt;LEVEL_77&gt;
     *       | &lt;LEVEL_78&gt;
     *       | &lt;LEVEL_88&gt;
     *       | &lt;LEVEL_NUMBER&gt;
     *       | &lt;INTEGER&gt;
     *       | &lt;COMMA_INTEGER&gt;
     * </PRE>
     */
    public void visit(IntegerConstant n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeOptional -&gt; ( &lt;PLUSCHAR&gt; | &lt;MINUSCHAR&gt; )?
     * nodeChoice -&gt; ( IntegerConstant() &lt;DOTCHAR&gt; [ IntegerConstant() ] | &lt;DOTCHAR&gt; IntegerConstant() | IntegerConstant() )
     * </PRE>
     */
    public void visit(NumericConstant n) throws Exception {
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;LEVEL_NUMBER&gt;
     * </PRE>
     */
    public void visit(LevelNumber n) throws Exception {
        n.nodeToken.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; &lt;ZERO&gt;
     *       | &lt;ZEROS&gt;
     *       | &lt;ZEROES&gt;
     *       | &lt;SPACE&gt;
     *       | &lt;SPACES&gt;
     *       | &lt;HIGH_VALUE&gt;
     *       | &lt;HIGH_VALUES&gt;
     *       | &lt;LOW_VALUE&gt;
     *       | &lt;LOW_VALUES&gt;
     *       | &lt;QUOTE&gt;
     *       | &lt;QUOTES&gt;
     *       | &lt;NULL&gt;
     *       | &lt;NULLS&gt;
     * </PRE>
     */
    public void visit(FigurativeConstant n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( &lt;QUOTEDSTRING&gt; | &lt;HEXNUMBER&gt; )
     * </PRE>
     */
    public void visit(NonNumericConstant n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeOptional -&gt; [ &lt;ALL&gt; ]
     * nodeChoice -&gt; ( NonNumericConstant() | NumericConstant() | FigurativeConstant() | IntrinsicFunction() | SpecialRegister() | &lt;LINAGE_COUNTER&gt; [ ( &lt;IN&gt; | &lt;OF&gt; ) FileName() ] )
     * </PRE>
     */
    public void visit(Literal n) throws Exception {
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * combinableCondition -&gt; CombinableCondition()
     * nodeListOptional -&gt; ( ( &lt;AND&gt; | &lt;OR&gt; ) ( CombinableCondition() | AbbreviationRest() ) )*
     * </PRE>
     */
    public void visit(Condition n) throws Exception {
        n.combinableCondition.accept(this);
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
    }

    /**
     * <PRE>
     * nodeOptional -&gt; [ &lt;NOT&gt; ]
     * simpleCondition -&gt; SimpleCondition()
     * </PRE>
     */
    public void visit(CombinableCondition n) throws Exception {
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.simpleCondition.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( ClassCondition() | RelationCondition() | ConditionNameCondition() | &lt;LPARENCHAR&gt; Condition() &lt;RPARENCHAR&gt; )
     * </PRE>
     */
    public void visit(SimpleCondition n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * identifier -&gt; Identifier()
     * nodeOptional -&gt; [ &lt;IS&gt; ]
     * nodeOptional1 -&gt; [ &lt;NOT&gt; ]
     * nodeChoice -&gt; ( &lt;NUMERIC&gt; | &lt;ALPHABETIC&gt; | &lt;ALPHABETIC_LOWER&gt; | &lt;ALPHABETIC_UPPER&gt; | ClassName() | &lt;DBCS&gt; | &lt;KANJI&gt; )
     * </PRE>
     */
    public void visit(ClassCondition n) throws Exception {
        n.identifier.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * conditionNameReference -&gt; ConditionNameReference()
     * </PRE>
     */
    public void visit(ConditionNameCondition n) throws Exception {
        n.conditionNameReference.accept(this);
    }

    /**
     * <PRE>
     * arithmeticExpression -&gt; ArithmeticExpression()
     * nodeChoice -&gt; ( RelationalOperator() ArithmeticExpression() | SignCondition() )
     * </PRE>
     */
    public void visit(RelationCondition n) throws Exception {
        n.arithmeticExpression.accept(this);
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeOptional -&gt; [ &lt;IS&gt; ]
     * nodeOptional1 -&gt; [ &lt;NOT&gt; ]
     * nodeChoice -&gt; ( &lt;POSITIVE&gt; | &lt;NEGATIVE&gt; | ( &lt;ZERO&gt; | &lt;ZEROS&gt; | &lt;ZEROES&gt; ) )
     * </PRE>
     */
    public void visit(SignCondition n) throws Exception {
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeOptional -&gt; [ &lt;IS&gt; ]
     * nodeOptional1 -&gt; [ &lt;NOT&gt; ]
     * nodeChoice -&gt; ( &lt;GREATER&gt; [ &lt;THAN&gt; ] &lt;OR&gt; &lt;EQUAL&gt; [ &lt;TO&gt; ] | &lt;MORETHANOREQUAL&gt; | &lt;LESS&gt; [ &lt;THAN&gt; ] &lt;OR&gt; &lt;EQUAL&gt; [ &lt;TO&gt; ] | &lt;LESSTHANOREQUAL&gt; | &lt;GREATER&gt; [ &lt;THAN&gt; ] | &lt;MORETHANCHAR&gt; | &lt;LESS&gt; [ &lt;THAN&gt; ] | &lt;LESSTHANCHAR&gt; | ( &lt;EQUAL&gt; | &lt;EQUALS&gt; ) [ &lt;TO&gt; ] | &lt;EQUALCHAR&gt; [ &lt;TO&gt; ] | &lt;NOTEQUALCHAR&gt; )
     * </PRE>
     */
    public void visit(RelationalOperator n) throws Exception {
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeList -&gt; ( [ &lt;NOT&gt; ] [ RelationalOperator() ] AbbreviationLeaf() )+
     * </PRE>
     */
    public void visit(AbbreviationRest n) throws Exception {
        processList(n.nodeList);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( ArithmeticExpression() | &lt;LPARENCHAR&gt; ArithmeticExpression() AbbreviationRest() &lt;RPARENCHAR&gt; )
     * </PRE>
     */
    public void visit(AbbreviationLeaf n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( ParagraphName() [ ( &lt;IN&gt; | &lt;OF&gt; ) SectionName() ] | SectionName() )
     * </PRE>
     */
    public void visit(ProcedureName n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( QualifiedDataName() ( &lt;LPARENCHAR&gt; Subscript() ( [ &lt;COMMACHAR&gt; ] Subscript() )* &lt;RPARENCHAR&gt; )* [ &lt;LPARENCHAR&gt; LeftmostCharacterPosition() &lt;COLONCHAR&gt; [ Length() ] &lt;RPARENCHAR&gt; ] | &lt;RETURN_CODE&gt; )
     * </PRE>
     */
    public void visit(Identifier n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeSequence -&gt; ( DataName() ( ( &lt;IN&gt; | &lt;OF&gt; ) DataName() )* [ ( &lt;IN&gt; | &lt;OF&gt; ) FileName() ] )
     * </PRE>
     */
    public void visit(QualifiedDataName n) throws Exception {
        n.nodeSequence.accept(this);
    }

    /**
     * <PRE>
     * nodeSequence -&gt; ( &lt;FUNCTION&gt; ( &lt;F_ACOS&gt; | &lt;F_ANNUITY&gt; | &lt;F_ASIN&gt; | &lt;F_ATAN&gt; | &lt;F_CHAR&gt; | &lt;F_COS&gt; | &lt;F_CURRENT_DATE&gt; | &lt;F_DATE_OF_INTEGER&gt; | &lt;F_DATE_TO_YYYYMMDD&gt; | &lt;F_DATEVAL&gt; | &lt;F_DAY_OF_INTEGER&gt; | &lt;F_DAY_TO_YYYYDDD&gt; | &lt;F_DISPLAY_OF&gt; | &lt;F_FACTORIAL&gt; | &lt;F_INTEGER&gt; | &lt;F_INTEGER_OF_DATE&gt; | &lt;F_INTEGER_OF_DAY&gt; | &lt;F_INTEGER_PART&gt; | &lt;F_LENGTH&gt; | &lt;F_LOG&gt; | &lt;F_LOG10&gt; | &lt;F_LOWER_CASE&gt; | &lt;F_MAX&gt; | &lt;F_MEAN&gt; | &lt;F_MEDIAN&gt; | &lt;F_MIDRANGE&gt; | &lt;F_MIN&gt; | &lt;F_MOD&gt; | &lt;F_NATIONAL_OF&gt; | &lt;F_NUMVAL&gt; | &lt;F_NUMVAL_C&gt; | &lt;F_ORD&gt; | &lt;F_ORD_MAX&gt; | &lt;F_ORD_MIN&gt; | &lt;F_PRESENT_VALUE&gt; | &lt;F_RANDOM&gt; | &lt;F_RANGE&gt; | &lt;F_REM&gt; | &lt;F_REVERSE&gt; | &lt;F_SIN&gt; | &lt;F_SQRT&gt; | &lt;F_STANDARD_DEVIATION&gt; | &lt;F_SUM&gt; | &lt;F_TAN&gt; | &lt;F_UNDATE&gt; | &lt;F_UPPER_CASE&gt; | &lt;F_VARIANCE&gt; | &lt;F_WHEN_COMPILED&gt; | &lt;F_YEAR_TO_YYYY&gt; | &lt;F_YEARWINDOW&gt; ) [ &lt;LPARENCHAR&gt; [ QualifiedDataName() &lt;LPARENCHAR&gt; ( &lt;ALL&gt; [ &lt;COMMACHAR&gt; ] )+ &lt;RPARENCHAR&gt; | FunctionArgument() ( [ &lt;COMMACHAR&gt; ] FunctionArgument() )* ] &lt;RPARENCHAR&gt; ] )
     * </PRE>
     */
    public void visit(IntrinsicFunction n) throws Exception {
        n.nodeSequence.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; Identifier()
     *       | Literal()
     *       | ArithmeticExpression()
     * </PRE>
     */
    public void visit(FunctionArgument n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * arithmeticExpression -&gt; ArithmeticExpression()
     * </PRE>
     */
    public void visit(Length n) throws Exception {
        n.arithmeticExpression.accept(this);
    }

    /**
     * <PRE>
     * arithmeticExpression -&gt; ArithmeticExpression()
     * </PRE>
     */
    public void visit(LeftmostCharacterPosition n) throws Exception {
        n.arithmeticExpression.accept(this);
    }

    /**
     * <PRE>
     * conditionName -&gt; ConditionName()
     * nodeChoice -&gt; ( ( ( &lt;IN&gt; | &lt;OF&gt; ) DataName() )* [ ( &lt;IN&gt; | &lt;OF&gt; ) FileName() ] ( &lt;LPARENCHAR&gt; Subscript() ( [ &lt;COMMACHAR&gt; ] Subscript() )* &lt;RPARENCHAR&gt; )* | ( ( &lt;IN&gt; | &lt;OF&gt; ) MnemonicName() )* )
     * </PRE>
     */
    public void visit(ConditionNameReference n) throws Exception {
        n.conditionName.accept(this);
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( [ ( &lt;PLUSCHAR_SUBS&gt; | &lt;PLUSCHAR&gt; ) | ( &lt;MINUSCHAR_SUBS&gt; | &lt;MINUSCHAR&gt; ) ] IntegerConstant() | QualifiedDataName() [ ( &lt;PLUSCHAR_SUBS&gt; | &lt;MINUSCHAR_SUBS&gt; ) IntegerConstant() ] | IndexName() [ ( &lt;PLUSCHAR_SUBS&gt; | &lt;MINUSCHAR_SUBS&gt; ) IntegerConstant() ] )
     * </PRE>
     */
    public void visit(Subscript n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * cobolWord -&gt; CobolWord()
     * </PRE>
     */
    public void visit(Mode n) throws Exception {
        n.cobolWord.accept(this);
    }

    /**
     * <PRE>
     * cobolWord -&gt; CobolWord()
     * </PRE>
     */
    public void visit(AlphabetName n) throws Exception {
        n.cobolWord.accept(this);
    }

    /**
     * <PRE>
     * cobolWord -&gt; CobolWord()
     * </PRE>
     */
    public void visit(ClassName n) throws Exception {
        n.cobolWord.accept(this);
    }

    /**
     * <PRE>
     * cobolWord -&gt; CobolWord()
     * </PRE>
     */
    public void visit(ConditionName n) throws Exception {
        n.cobolWord.accept(this);
    }

    /**
     * <PRE>
     * cobolWord -&gt; CobolWord()
     * </PRE>
     */
    public void visit(DataName n) throws Exception {
        n.cobolWord.accept(this);
    }

    /**
     * <PRE>
     * cobolWord -&gt; CobolWord()
     * </PRE>
     */
    public void visit(FileName n) throws Exception {
        n.cobolWord.accept(this);
    }

    /**
     * <PRE>
     * cobolWord -&gt; CobolWord()
     * </PRE>
     */
    public void visit(IndexName n) throws Exception {
        n.cobolWord.accept(this);
    }

    /**
     * <PRE>
     * cobolWord -&gt; CobolWord()
     * </PRE>
     */
    public void visit(MnemonicName n) throws Exception {
        n.cobolWord.accept(this);
    }

    /**
     * <PRE>
     * qualifiedDataName -&gt; QualifiedDataName()
     * </PRE>
     */
    public void visit(RecordName n) throws Exception {
        n.qualifiedDataName.accept(this);
    }

    /**
     * <PRE>
     * cobolWord -&gt; CobolWord()
     * </PRE>
     */
    public void visit(RoutineName n) throws Exception {
        n.cobolWord.accept(this);
    }

    /**
     * <PRE>
     * cobolWord -&gt; CobolWord()
     * </PRE>
     */
    public void visit(SymbolicCharacter n) throws Exception {
        n.cobolWord.accept(this);
    }

    /**
     * <PRE>
     * cobolWord -&gt; CobolWord()
     * </PRE>
     */
    public void visit(LibraryName n) throws Exception {
        n.cobolWord.accept(this);
    }

    /**
     * <PRE>
     * cobolWord -&gt; CobolWord()
     * </PRE>
     */
    public void visit(ProgramName n) throws Exception {
        n.cobolWord.accept(this);
    }

    /**
     * <PRE>
     * cobolWord -&gt; CobolWord()
     * </PRE>
     */
    public void visit(CdName n) throws Exception {
        n.cobolWord.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; &lt;LEVEL_66&gt;
     *       | &lt;LEVEL_77&gt;
     *       | &lt;LEVEL_78&gt;
     *       | &lt;LEVEL_88&gt;
     *       | &lt;LEVEL_NUMBER&gt;
     *       | &lt;INTEGER&gt;
     *       | CobolWord()
     * </PRE>
     */
    public void visit(SectionName n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; &lt;LEVEL_66&gt;
     *       | &lt;LEVEL_77&gt;
     *       | &lt;LEVEL_78&gt;
     *       | &lt;LEVEL_88&gt;
     *       | &lt;LEVEL_NUMBER&gt;
     *       | &lt;INTEGER&gt;
     *       | CobolWord()
     * </PRE>
     */
    public void visit(ParagraphName n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * cobolWord -&gt; CobolWord()
     * </PRE>
     */
    public void visit(SystemName n) throws Exception {
        n.cobolWord.accept(this);
    }

    /**
     * <PRE>
     * systemName -&gt; SystemName()
     * </PRE>
     */
    public void visit(ComputerName n) throws Exception {
        n.systemName.accept(this);
    }

    /**
     * <PRE>
     * systemName -&gt; SystemName()
     * </PRE>
     */
    public void visit(LanguageName n) throws Exception {
        n.systemName.accept(this);
    }

    /**
     * <PRE>
     * systemName -&gt; SystemName()
     * </PRE>
     */
    public void visit(EnvironmentName n) throws Exception {
        n.systemName.accept(this);
    }

    /**
     * <PRE>
     * systemName -&gt; SystemName()
     * </PRE>
     */
    public void visit(AssignmentName n) throws Exception {
        n.systemName.accept(this);
    }

    /**
     * <PRE>
     * programName -&gt; ProgramName()
     * </PRE>
     */
    public void visit(BasisName n) throws Exception {
        n.programName.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( &lt;ADDRESS&gt; &lt;OF&gt; DataName() | &lt;LENGTH&gt; &lt;OF&gt; Identifier() | &lt;DEBUG_LINE&gt; | &lt;DEBUG_NAME&gt; | &lt;DEBUG_CONTENTS&gt; | &lt;DEBUG_ITEM&gt; | &lt;DEBUG_SUB_1&gt; | &lt;DEBUG_SUB_2&gt; | &lt;DEBUG_SUB_3&gt; | &lt;RETURN_CODE&gt; | &lt;SHIFT_OUT&gt; | &lt;SHIFT_IN&gt; | &lt;SORT_CONTROL&gt; | &lt;SORT_CORE_SIZE&gt; | &lt;SORT_FILE_SIZE&gt; | &lt;SORT_MESSAGE&gt; | &lt;SORT_MODE_SIZE&gt; | &lt;SORT_RETURN&gt; | &lt;TALLY&gt; | &lt;WHEN_COMPILED&gt; )
     * </PRE>
     */
    public void visit(SpecialRegister n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * timesDiv -&gt; TimesDiv()
     * nodeListOptional -&gt; ( ( ( &lt;PLUSCHAR_SUBS&gt; | &lt;PLUSCHAR&gt; ) | ( &lt;MINUSCHAR_SUBS&gt; | &lt;MINUSCHAR&gt; ) ) TimesDiv() )*
     * </PRE>
     */
    public void visit(ArithmeticExpression n) throws Exception {
        n.timesDiv.accept(this);
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
    }

    /**
     * <PRE>
     * power -&gt; Power()
     * nodeListOptional -&gt; ( ( &lt;ASTERISKCHAR&gt; | &lt;SLASHCHAR&gt; ) Power() )*
     * </PRE>
     */
    public void visit(TimesDiv n) throws Exception {
        n.power.accept(this);
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
    }

    /**
     * <PRE>
     * nodeOptional -&gt; [ ( ( &lt;PLUSCHAR_SUBS&gt; | &lt;PLUSCHAR&gt; ) | ( &lt;MINUSCHAR_SUBS&gt; | &lt;MINUSCHAR&gt; ) ) ]
     * basis -&gt; Basis()
     * nodeListOptional -&gt; ( &lt;POW&gt; Basis() )*
     * </PRE>
     */
    public void visit(Power n) throws Exception {
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.basis.accept(this);
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( Identifier() | Literal() | &lt;LPARENCHAR&gt; ArithmeticExpression() &lt;RPARENCHAR&gt; )
     * </PRE>
     */
    public void visit(Basis n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeList -&gt; ( &lt;COMMENT2&gt; [ &lt;DOT2&gt; ] )+
     * </PRE>
     */
    public void visit(CommentLine n) throws Exception {
        processList(n.nodeList);
    }

    /**
     * <PRE>
     * nodeListOptional -&gt; ( ProgramUnit() ( NestedProgramUnit() )* [ EndProgramStatement() ] )*
     * nodeToken -&gt; &lt;EOF&gt;
     * </PRE>
     */
    public void visit(CompilationUnit n) throws Exception {
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
        n.nodeToken.accept(this);
    }

    /**
     * <PRE>
     * identificationDivision -&gt; IdentificationDivision()
     * nodeOptional -&gt; [ EnvironmentDivision() ]
     * nodeOptional1 -&gt; [ DataDivision() ]
     * nodeOptional2 -&gt; [ ProcedureDivision() ]
     * </PRE>
     */
    public void visit(ProgramUnit n) throws Exception {
        n.identificationDivision.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        if (n.nodeOptional2.present()) {
            n.nodeOptional2.accept(this);
        }
    }

    /**
     * <PRE>
     * nestedIdentificationDivision -&gt; NestedIdentificationDivision()
     * nodeOptional -&gt; [ EnvironmentDivision() ]
     * nodeOptional1 -&gt; [ DataDivision() ]
     * nodeOptional2 -&gt; [ ProcedureDivision() ]
     * nodeListOptional -&gt; ( NestedProgramUnit() )*
     * endProgramStatement -&gt; EndProgramStatement()
     * </PRE>
     */
    public void visit(NestedProgramUnit n) throws Exception {
        n.nestedIdentificationDivision.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        if (n.nodeOptional2.present()) {
            n.nodeOptional2.accept(this);
        }
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
        n.endProgramStatement.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;END&gt;
     * nodeToken1 -&gt; &lt;PROGRAM&gt;
     * programName -&gt; ProgramName()
     * nodeToken2 -&gt; &lt;DOT&gt;
     * </PRE>
     */
    public void visit(EndProgramStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
        n.programName.accept(this);
        n.nodeToken2.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;IDENTIFICATION&gt;
     * nodeToken1 -&gt; &lt;DIVISION&gt;
     * nodeToken2 -&gt; &lt;DOT&gt;
     * programIdParagraph -&gt; ProgramIdParagraph()
     * nodeListOptional -&gt; ( IdentificationDivisionParagraph() )*
     * </PRE>
     */
    public void visit(IdentificationDivision n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
        n.nodeToken2.accept(this);
        n.programIdParagraph.accept(this);
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( &lt;IDENTIFICATION&gt; | &lt;ID&gt; )
     * nodeToken -&gt; &lt;DIVISION&gt;
     * nodeToken1 -&gt; &lt;DOT&gt;
     * nestedProgramIdParagraph -&gt; NestedProgramIdParagraph()
     * nodeListOptional -&gt; ( IdentificationDivisionParagraph() )*
     * </PRE>
     */
    public void visit(NestedIdentificationDivision n) throws Exception {
        n.nodeChoice.accept(this);
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
        n.nestedProgramIdParagraph.accept(this);
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; AuthorParagraph()
     *       | InstallationParagraph()
     *       | DateWrittenParagraph()
     *       | DateCompiledParagraph()
     *       | SecurityParagraph()
     * </PRE>
     */
    public void visit(IdentificationDivisionParagraph n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;PROGRAM_ID&gt;
     * nodeToken1 -&gt; &lt;DOT&gt;
     * programName -&gt; ProgramName()
     * nodeOptional -&gt; [ [ &lt;IS&gt; ] &lt;INITIAL&gt; [ &lt;PROGRAM&gt; ] ]
     * nodeToken2 -&gt; &lt;DOT&gt;
     * </PRE>
     */
    public void visit(ProgramIdParagraph n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
        n.programName.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeToken2.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;PROGRAM_ID&gt;
     * nodeToken1 -&gt; &lt;DOT&gt;
     * programName -&gt; ProgramName()
     * nodeOptional -&gt; [ [ &lt;IS&gt; ] InitialOrCommon() [ &lt;PROGRAM&gt; ] ]
     * nodeToken2 -&gt; &lt;DOT&gt;
     * </PRE>
     */
    public void visit(NestedProgramIdParagraph n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
        n.programName.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeToken2.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( &lt;INITIAL&gt; [ &lt;COMMON&gt; ] | &lt;COMMON&gt; [ &lt;INITIAL&gt; ] )
     * </PRE>
     */
    public void visit(InitialOrCommon n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( &lt;AUTHOR&gt; | &lt;AUTHOR2&gt; )
     * nodeChoice1 -&gt; ( &lt;DOT2&gt; | &lt;DOT&gt; )
     * nodeOptional -&gt; [ CommentLine() ]
     * </PRE>
     */
    public void visit(AuthorParagraph n) throws Exception {
        n.nodeChoice.accept(this);
        n.nodeChoice1.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( &lt;INSTALLATION&gt; | &lt;INSTALLATION2&gt; )
     * nodeChoice1 -&gt; ( &lt;DOT2&gt; | &lt;DOT&gt; )
     * nodeOptional -&gt; [ CommentLine() ]
     * </PRE>
     */
    public void visit(InstallationParagraph n) throws Exception {
        n.nodeChoice.accept(this);
        n.nodeChoice1.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( &lt;DATE_WRITTEN&gt; | &lt;DATE_WRITTEN2&gt; )
     * nodeChoice1 -&gt; ( &lt;DOT2&gt; | &lt;DOT&gt; )
     * nodeOptional -&gt; [ CommentLine() ]
     * </PRE>
     */
    public void visit(DateWrittenParagraph n) throws Exception {
        n.nodeChoice.accept(this);
        n.nodeChoice1.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( &lt;DATE_COMPILED&gt; | &lt;DATE_COMPILED2&gt; )
     * nodeChoice1 -&gt; ( &lt;DOT2&gt; | &lt;DOT&gt; )
     * nodeOptional -&gt; [ CommentLine() ]
     * </PRE>
     */
    public void visit(DateCompiledParagraph n) throws Exception {
        n.nodeChoice.accept(this);
        n.nodeChoice1.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( &lt;SECURITY&gt; | &lt;SECURITY2&gt; )
     * nodeChoice1 -&gt; ( &lt;DOT2&gt; | &lt;DOT&gt; )
     * nodeOptional -&gt; [ CommentLine() ]
     * </PRE>
     */
    public void visit(SecurityParagraph n) throws Exception {
        n.nodeChoice.accept(this);
        n.nodeChoice1.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( &lt;ENVIRONMENT&gt; &lt;DIVISION&gt; &lt;DOT&gt; | &lt;ENVIRONMENT_DIVISION&gt; )
     * nodeListOptional -&gt; ( EnvironmentSection() )*
     * </PRE>
     */
    public void visit(EnvironmentDivision n) throws Exception {
        n.nodeChoice.accept(this);
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ConfigurationSection()
     *       | InputOutputSection()
     * </PRE>
     */
    public void visit(EnvironmentSection n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;CONFIGURATION&gt;
     * nodeToken1 -&gt; &lt;SECTION&gt;
     * nodeToken2 -&gt; &lt;DOT&gt;
     * nodeListOptional -&gt; ( ConfigurationSectionParagraph() )*
     * </PRE>
     */
    public void visit(ConfigurationSection n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
        n.nodeToken2.accept(this);
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; SourceComputerParagraph()
     *       | ObjectComputerParagraph()
     *       | SpecialNamesParagraph()
     * </PRE>
     */
    public void visit(ConfigurationSectionParagraph n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;SOURCE_COMPUTER&gt;
     * nodeToken1 -&gt; &lt;DOT&gt;
     * computerName -&gt; ComputerName()
     * nodeOptional -&gt; [ [ &lt;WITH&gt; ] &lt;DEBUGGING&gt; &lt;MODE&gt; ]
     * nodeToken2 -&gt; &lt;DOT&gt;
     * </PRE>
     */
    public void visit(SourceComputerParagraph n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
        n.computerName.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeToken2.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;OBJECT_COMPUTER&gt;
     * nodeToken1 -&gt; &lt;DOT&gt;
     * computerName -&gt; ComputerName()
     * nodeListOptional -&gt; ( ObjectComputerClause() )*
     * nodeToken2 -&gt; &lt;DOT&gt;
     * </PRE>
     */
    public void visit(ObjectComputerParagraph n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
        n.computerName.accept(this);
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
        n.nodeToken2.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; MemorySizeClause()
     *       | CollatingSequenceClause()
     *       | SegmentLimitClause()
     *       | CharacterSetClause()
     * </PRE>
     */
    public void visit(ObjectComputerClause n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;MEMORY&gt;
     * nodeOptional -&gt; [ &lt;SIZE&gt; ]
     * integerConstant -&gt; IntegerConstant()
     * nodeOptional1 -&gt; [ &lt;WORDS&gt; | &lt;CHARACTERS&gt; | &lt;MODULES&gt; ]
     * </PRE>
     */
    public void visit(MemorySizeClause n) throws Exception {
        n.nodeToken.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.integerConstant.accept(this);
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeOptional -&gt; [ &lt;PROGRAM&gt; ]
     * nodeOptional1 -&gt; [ &lt;COLLATING&gt; ]
     * nodeToken -&gt; &lt;SEQUENCE&gt;
     * nodeOptional2 -&gt; [ &lt;IS&gt; ]
     * alphabetName -&gt; AlphabetName()
     * </PRE>
     */
    public void visit(CollatingSequenceClause n) throws Exception {
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        n.nodeToken.accept(this);
        if (n.nodeOptional2.present()) {
            n.nodeOptional2.accept(this);
        }
        n.alphabetName.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;SEGMENT_LIMIT&gt;
     * nodeOptional -&gt; [ &lt;IS&gt; ]
     * integerConstant -&gt; IntegerConstant()
     * </PRE>
     */
    public void visit(SegmentLimitClause n) throws Exception {
        n.nodeToken.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.integerConstant.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;CHARACTER&gt;
     * nodeToken1 -&gt; &lt;SET&gt;
     * </PRE>
     */
    public void visit(CharacterSetClause n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;SPECIAL_NAMES&gt;
     * nodeToken1 -&gt; &lt;DOT&gt;
     * nodeOptional -&gt; [ SpecialNameClause() ( [ &lt;COMMACHAR&gt; ] SpecialNameClause() )* &lt;DOT&gt; ]
     * </PRE>
     */
    public void visit(SpecialNamesParagraph n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; AlphabetClause()
     *       | ClassClause()
     *       | CurrencySignClause()
     *       | DecimalPointClause()
     *       | SymbolicCharactersClause()
     *       | EnvironmentNameIsMnemonicNameClause()
     * </PRE>
     */
    public void visit(SpecialNameClause n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;ALPHABET&gt;
     * alphabetName -&gt; AlphabetName()
     * nodeOptional -&gt; [ &lt;IS&gt; ]
     * nodeChoice -&gt; ( &lt;STANDARD_1&gt; | &lt;STANDARD_2&gt; | &lt;NATIVE&gt; | CobolWord() | ( Literal() [ ( ( &lt;THROUGH&gt; | &lt;THRU&gt; ) Literal() | ( &lt;ALSO&gt; Literal() [ &lt;COMMACHAR&gt; ] )+ ) ] [ &lt;COMMACHAR&gt; ] )+ )
     * </PRE>
     */
    public void visit(AlphabetClause n) throws Exception {
        n.nodeToken.accept(this);
        n.alphabetName.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;CLASS&gt;
     * className -&gt; ClassName()
     * nodeOptional -&gt; [ &lt;IS&gt; ]
     * nodeList -&gt; ( Literal() [ ( &lt;THROUGH&gt; | &lt;THRU&gt; ) Literal() ] )+
     * </PRE>
     */
    public void visit(ClassClause n) throws Exception {
        n.nodeToken.accept(this);
        n.className.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        processList(n.nodeList);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;CURRENCY&gt;
     * nodeOptional -&gt; [ &lt;SIGN&gt; ]
     * nodeOptional1 -&gt; [ &lt;IS&gt; ]
     * literal -&gt; Literal()
     * </PRE>
     */
    public void visit(CurrencySignClause n) throws Exception {
        n.nodeToken.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        n.literal.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;DECIMAL_POINT&gt;
     * nodeOptional -&gt; [ &lt;IS&gt; ]
     * nodeToken1 -&gt; &lt;COMMA&gt;
     * </PRE>
     */
    public void visit(DecimalPointClause n) throws Exception {
        n.nodeToken.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeToken1.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;SYMBOLIC&gt;
     * nodeOptional -&gt; [ &lt;CHARACTERS&gt; ]
     * nodeList -&gt; ( ( SymbolicCharacter() )+ [ ( &lt;ARE&gt; | &lt;IS&gt; ) ] ( IntegerConstant() )+ )+
     * nodeOptional1 -&gt; [ &lt;IN&gt; AlphabetName() ]
     * </PRE>
     */
    public void visit(SymbolicCharactersClause n) throws Exception {
        n.nodeToken.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        processList(n.nodeList);
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( EnvironmentName() [ &lt;IS&gt; ] MnemonicName() [ SpecialNamesParagraphStatusPhrase() ] | SpecialNamesParagraphStatusPhrase() )
     * </PRE>
     */
    public void visit(EnvironmentNameIsMnemonicNameClause n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( &lt;ON&gt; [ &lt;STATUS&gt; ] [ &lt;IS&gt; ] Condition() [ &lt;OFF&gt; [ &lt;STATUS&gt; ] [ &lt;IS&gt; ] Condition() ] | &lt;OFF&gt; [ &lt;STATUS&gt; ] [ &lt;IS&gt; ] Condition() [ &lt;ON&gt; [ &lt;STATUS&gt; ] [ &lt;IS&gt; ] Condition() ] )
     * </PRE>
     */
    public void visit(SpecialNamesParagraphStatusPhrase n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeOptional -&gt; [ &lt;INPUT_OUTPUT&gt; &lt;SECTION&gt; &lt;DOT&gt; ]
     * nodeList -&gt; ( InputOutputSectionParagraph() )+
     * </PRE>
     */
    public void visit(InputOutputSection n) throws Exception {
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        processList(n.nodeList);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; FileControlParagraph()
     *       | IOControlParagraph()
     * </PRE>
     */
    public void visit(InputOutputSectionParagraph n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( &lt;FILE_CONTROL&gt; &lt;DOT&gt; | FileControlEntry() &lt;DOT&gt; )
     * nodeListOptional -&gt; ( FileControlEntry() &lt;DOT&gt; )*
     * </PRE>
     */
    public void visit(FileControlParagraph n) throws Exception {
        n.nodeChoice.accept(this);
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
    }

    /**
     * <PRE>
     * selectClause -&gt; SelectClause()
     * nodeListOptional -&gt; ( FileControlClause() )*
     * </PRE>
     */
    public void visit(FileControlEntry n) throws Exception {
        n.selectClause.accept(this);
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; AssignClause()
     *       | ReserveClause()
     *       | KeyClause()
     *       | OrganizationClause()
     *       | PaddingCharacterClause()
     *       | RecordDelimiterClause()
     *       | AccessModeClause()
     *       | AlternateRecordKeyClause()
     *       | FileStatusClause()
     *       | PasswordClause()
     * </PRE>
     */
    public void visit(FileControlClause n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;SELECT&gt;
     * nodeOptional -&gt; [ &lt;OPTIONAL&gt; ]
     * fileName -&gt; FileName()
     * </PRE>
     */
    public void visit(SelectClause n) throws Exception {
        n.nodeToken.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.fileName.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;ASSIGN&gt;
     * nodeOptional -&gt; [ &lt;TO&gt; ]
     * nodeOptional1 -&gt; [ &lt;DISK&gt; ]
     * nodeChoice -&gt; ( AssignmentName() | Literal() )
     * </PRE>
     */
    public void visit(AssignClause n) throws Exception {
        n.nodeToken.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;RESERVE&gt;
     * integerConstant -&gt; IntegerConstant()
     * nodeOptional -&gt; ( &lt;AREA&gt; | &lt;AREAS&gt; )?
     * </PRE>
     */
    public void visit(ReserveClause n) throws Exception {
        n.nodeToken.accept(this);
        n.integerConstant.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeOptional -&gt; [ &lt;ORGANIZATION&gt; ]
     * nodeOptional1 -&gt; [ &lt;IS&gt; ]
     * nodeChoice -&gt; ( SequentialOrganizationClause() | IndexedOrganizationClause() | RelativeOrganizationClause() | LineSequentialOrganizationClause() )
     * </PRE>
     */
    public void visit(OrganizationClause n) throws Exception {
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;SEQUENTIAL&gt;
     * </PRE>
     */
    public void visit(SequentialOrganizationClause n) throws Exception {
        n.nodeToken.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;LINE&gt;
     * nodeToken1 -&gt; &lt;SEQUENTIAL&gt;
     * </PRE>
     */
    public void visit(LineSequentialOrganizationClause n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;RELATIVE&gt;
     * </PRE>
     */
    public void visit(RelativeOrganizationClause n) throws Exception {
        n.nodeToken.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;INDEXED&gt;
     * </PRE>
     */
    public void visit(IndexedOrganizationClause n) throws Exception {
        n.nodeToken.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;PADDING&gt;
     * nodeOptional -&gt; [ &lt;CHARACTER&gt; ]
     * nodeOptional1 -&gt; [ &lt;IS&gt; ]
     * nodeChoice -&gt; ( QualifiedDataName() | Literal() )
     * </PRE>
     */
    public void visit(PaddingCharacterClause n) throws Exception {
        n.nodeToken.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;RECORD&gt;
     * nodeToken1 -&gt; &lt;DELIMITER&gt;
     * nodeOptional -&gt; [ &lt;IS&gt; ]
     * nodeChoice -&gt; ( &lt;STANDARD_1&gt; | &lt;IMPLICIT&gt; | AssignmentName() )
     * </PRE>
     */
    public void visit(RecordDelimiterClause n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;ACCESS&gt;
     * nodeOptional -&gt; [ &lt;MODE&gt; ]
     * nodeOptional1 -&gt; [ &lt;IS&gt; ]
     * nodeChoice -&gt; ( SequentialAccessMode() | RandomAccessMode() | DynamicAccessMode() )
     * </PRE>
     */
    public void visit(AccessModeClause n) throws Exception {
        n.nodeToken.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;SEQUENTIAL&gt;
     * </PRE>
     */
    public void visit(SequentialAccessMode n) throws Exception {
        n.nodeToken.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;RANDOM&gt;
     * </PRE>
     */
    public void visit(RandomAccessMode n) throws Exception {
        n.nodeToken.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;DYNAMIC&gt;
     * </PRE>
     */
    public void visit(DynamicAccessMode n) throws Exception {
        n.nodeToken.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( &lt;RELATIVE&gt; | &lt;RECORD&gt; )
     * nodeOptional -&gt; [ &lt;KEY&gt; ]
     * nodeOptional1 -&gt; [ &lt;IS&gt; ]
     * qualifiedDataName -&gt; QualifiedDataName()
     * </PRE>
     */
    public void visit(KeyClause n) throws Exception {
        n.nodeChoice.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        n.qualifiedDataName.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;ALTERNATE&gt;
     * nodeToken1 -&gt; &lt;RECORD&gt;
     * nodeOptional -&gt; [ &lt;KEY&gt; ]
     * nodeOptional1 -&gt; [ &lt;IS&gt; ]
     * qualifiedDataName -&gt; QualifiedDataName()
     * nodeOptional2 -&gt; [ PasswordClause() ]
     * nodeOptional3 -&gt; [ [ &lt;WITH&gt; ] &lt;DUPLICATES&gt; ]
     * </PRE>
     */
    public void visit(AlternateRecordKeyClause n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        n.qualifiedDataName.accept(this);
        if (n.nodeOptional2.present()) {
            n.nodeOptional2.accept(this);
        }
        if (n.nodeOptional3.present()) {
            n.nodeOptional3.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;PASSWORD&gt;
     * nodeOptional -&gt; [ &lt;IS&gt; ]
     * dataName -&gt; DataName()
     * </PRE>
     */
    public void visit(PasswordClause n) throws Exception {
        n.nodeToken.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.dataName.accept(this);
    }

    /**
     * <PRE>
     * nodeOptional -&gt; [ &lt;FILE&gt; ]
     * nodeToken -&gt; &lt;STATUS&gt;
     * nodeOptional1 -&gt; [ &lt;IS&gt; ]
     * qualifiedDataName -&gt; QualifiedDataName()
     * nodeOptional2 -&gt; [ QualifiedDataName() ]
     * </PRE>
     */
    public void visit(FileStatusClause n) throws Exception {
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeToken.accept(this);
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        n.qualifiedDataName.accept(this);
        if (n.nodeOptional2.present()) {
            n.nodeOptional2.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;I_O_CONTROL&gt;
     * nodeToken1 -&gt; &lt;DOT&gt;
     * nodeOptional -&gt; [ IOControlClause() ( [ &lt;DOT&gt; ] IOControlClause() )* &lt;DOT&gt; ]
     * </PRE>
     */
    public void visit(IOControlParagraph n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeOptional -&gt; [ &lt;COMMACHAR&gt; ]
     * nodeChoice -&gt; ( RerunClause() | SameAreaClause() | MultipleFileClause() )
     * nodeOptional1 -&gt; [ &lt;COMMACHAR&gt; ]
     * </PRE>
     */
    public void visit(IOControlClause n) throws Exception {
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeChoice.accept(this);
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;RERUN&gt;
     * nodeOptional -&gt; [ &lt;ON&gt; ( AssignmentName() | FileName() ) ]
     * nodeToken1 -&gt; &lt;EVERY&gt;
     * nodeChoice -&gt; ( Rerun2() | IntegerConstant() [ &lt;CLOCK_UNITS&gt; ] )
     * </PRE>
     */
    public void visit(RerunClause n) throws Exception {
        n.nodeToken.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeToken1.accept(this);
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; IntegerConstant() &lt;RECORDS&gt;
     *       | [ &lt;END&gt; ] [ &lt;OF&gt; ] ( &lt;REEL&gt; | &lt;UNIT&gt; ) &lt;OF&gt; FileName()
     * </PRE>
     */
    public void visit(Rerun2 n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;SAME&gt;
     * nodeOptional -&gt; [ &lt;RECORD&gt; | &lt;SORT&gt; | &lt;SORT_MERGE&gt; ]
     * nodeOptional1 -&gt; [ &lt;AREA&gt; ]
     * nodeOptional2 -&gt; [ &lt;FOR&gt; ]
     * nodeList -&gt; ( FileName() [ &lt;COMMACHAR&gt; ] )+
     * </PRE>
     */
    public void visit(SameAreaClause n) throws Exception {
        n.nodeToken.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        if (n.nodeOptional2.present()) {
            n.nodeOptional2.accept(this);
        }
        processList(n.nodeList);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;MULTIPLE&gt;
     * nodeToken1 -&gt; &lt;FILE&gt;
     * nodeOptional -&gt; [ &lt;TAPE&gt; ]
     * nodeOptional1 -&gt; [ &lt;CONTAINS&gt; ]
     * nodeList -&gt; ( FileName() [ &lt;POSITION&gt; ] [ IntegerConstant() ] [ &lt;COMMACHAR&gt; ] )+
     * </PRE>
     */
    public void visit(MultipleFileClause n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        processList(n.nodeList);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( &lt;DATA&gt; &lt;DIVISION&gt; &lt;DOT&gt; | &lt;DATA_DIVISION&gt; )
     * nodeListOptional -&gt; ( DataDivisionSection() )*
     * </PRE>
     */
    public void visit(DataDivision n) throws Exception {
        n.nodeChoice.accept(this);
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; FileSection()
     *       | WorkingStorageSection()
     *       | LinkageSection()
     *       | CommunicationSection()
     * </PRE>
     */
    public void visit(DataDivisionSection n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;COMMUNICATION&gt;
     * nodeToken1 -&gt; &lt;SECTION&gt;
     * nodeToken2 -&gt; &lt;DOT&gt;
     * nodeListOptional -&gt; ( CommunicationDescriptionEntry() ( DataDescriptionEntry() )* )*
     * </PRE>
     */
    public void visit(CommunicationSection n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
        n.nodeToken2.accept(this);
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( CommunicationInputEntry() | CommunicationOutputEntry() | CommunicationIOEntry() )
     * nodeToken -&gt; &lt;DOT&gt;
     * </PRE>
     */
    public void visit(CommunicationDescriptionEntry n) throws Exception {
        n.nodeChoice.accept(this);
        n.nodeToken.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;CD&gt;
     * cdName -&gt; CdName()
     * nodeOptional -&gt; [ &lt;FOR&gt; ]
     * nodeOptional1 -&gt; [ &lt;INITIAL&gt; ]
     * nodeToken1 -&gt; &lt;INPUT&gt;
     * nodeListOptional -&gt; ( CommunicationInputClause() )*
     * nodeListOptional1 -&gt; ( DataName() | &lt;FILLER&gt; )*
     * </PRE>
     */
    public void visit(CommunicationInputEntry n) throws Exception {
        n.nodeToken.accept(this);
        n.cdName.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        n.nodeToken1.accept(this);
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
        if (n.nodeListOptional1.present()) {
            processList(n.nodeListOptional1);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;CD&gt;
     * cdName -&gt; CdName()
     * nodeOptional -&gt; [ &lt;FOR&gt; ]
     * nodeToken1 -&gt; &lt;OUTPUT&gt;
     * nodeListOptional -&gt; ( CommunicationOutputClause() )*
     * </PRE>
     */
    public void visit(CommunicationOutputEntry n) throws Exception {
        n.nodeToken.accept(this);
        n.cdName.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeToken1.accept(this);
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;CD&gt;
     * cdName -&gt; CdName()
     * nodeOptional -&gt; [ &lt;FOR&gt; ]
     * nodeOptional1 -&gt; [ &lt;INITIAL&gt; ]
     * nodeToken1 -&gt; &lt;I_O&gt;
     * nodeListOptional -&gt; ( CommunicationIOClause() )*
     * nodeListOptional1 -&gt; ( DataName() | &lt;FILLER&gt; )*
     * </PRE>
     */
    public void visit(CommunicationIOEntry n) throws Exception {
        n.nodeToken.accept(this);
        n.cdName.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        n.nodeToken1.accept(this);
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
        if (n.nodeListOptional1.present()) {
            processList(n.nodeListOptional1);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; &lt;MESSAGE&gt; ( &lt;DATE&gt; | &lt;TIME&gt; | &lt;COUNT&gt; ) [ &lt;IS&gt; ] DataName()
     *       | &lt;TEXT&gt; &lt;LENGTH&gt; [ &lt;IS&gt; ] DataName()
     *       | &lt;END&gt; &lt;KEY&gt; [ &lt;IS&gt; ] DataName()
     *       | &lt;STATUS&gt; &lt;KEY&gt; [ &lt;IS&gt; ] DataName()
     *       | &lt;COUNT&gt; [ &lt;IS&gt; ] DataName()
     *       | [ &lt;SYMBOLIC&gt; ] ( &lt;QUEUE&gt; | &lt;SUB_QUEUE_1&gt; | &lt;SUB_QUEUE_2&gt; | &lt;SUB_QUEUE_3&gt; | &lt;SOURCE&gt; ) [ &lt;IS&gt; ] DataName()
     * </PRE>
     */
    public void visit(CommunicationInputClause n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; &lt;DESTINATION&gt; &lt;COUNT&gt; [ &lt;IS&gt; ] DataName()
     *       | &lt;TEXT&gt; &lt;LENGTH&gt; [ &lt;IS&gt; ] DataName()
     *       | &lt;STATUS&gt; &lt;KEY&gt; [ &lt;IS&gt; ] DataName()
     *       | [ &lt;SYMBOLIC&gt; ] &lt;DESTINATION&gt; [ &lt;IS&gt; ] DataName()
     *       | &lt;DESTINATION&gt; &lt;TABLE&gt; &lt;OCCURS&gt; IntegerConstant() [ &lt;TIMES&gt; ] [ &lt;INDEXED&gt; [ &lt;BY&gt; ] ( IndexName() [ &lt;COMMACHAR&gt; ] )+ ]
     *       | &lt;ERROR&gt; &lt;KEY&gt; [ &lt;IS&gt; ] DataName()
     * </PRE>
     */
    public void visit(CommunicationOutputClause n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; &lt;MESSAGE&gt; ( &lt;DATE&gt; | &lt;TIME&gt; ) [ &lt;IS&gt; ] DataName()
     *       | &lt;TEXT&gt; &lt;LENGTH&gt; [ &lt;IS&gt; ] DataName()
     *       | &lt;END&gt; &lt;KEY&gt; [ &lt;IS&gt; ] DataName()
     *       | &lt;STATUS&gt; &lt;KEY&gt; [ &lt;IS&gt; ] DataName()
     *       | [ &lt;SYMBOLIC&gt; ] &lt;TERMINAL&gt; [ &lt;IS&gt; ] DataName()
     * </PRE>
     */
    public void visit(CommunicationIOClause n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( ( &lt;FILE&gt; &lt;SECTION&gt; &lt;DOT&gt; ) | ( FileAndSortDescriptionEntry() ( DataDescriptionEntry() )+ ) )
     * nodeListOptional -&gt; ( FileAndSortDescriptionEntry() ( DataDescriptionEntry() )+ )*
     * </PRE>
     */
    public void visit(FileSection n) throws Exception {
        n.nodeChoice.accept(this);
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( &lt;FD&gt; | &lt;SD&gt; )
     * fileName -&gt; FileName()
     * nodeListOptional -&gt; ( FileAndSortDescriptionEntryClause() )*
     * nodeToken -&gt; &lt;DOT&gt;
     * </PRE>
     */
    public void visit(FileAndSortDescriptionEntry n) throws Exception {
        n.nodeChoice.accept(this);
        n.fileName.accept(this);
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
        n.nodeToken.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ExternalClause()
     *       | GlobalClause()
     *       | BlockContainsClause()
     *       | RecordContainsClause()
     *       | LabelRecordsClause()
     *       | ValueOfClause()
     *       | DataRecordClause()
     *       | LinageClause()
     *       | CodeSetClause()
     *       | ReportClause()
     *       | RecordingModeClause()
     * </PRE>
     */
    public void visit(FileAndSortDescriptionEntryClause n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeOptional -&gt; [ &lt;IS&gt; ]
     * nodeToken -&gt; &lt;EXTERNAL&gt;
     * </PRE>
     */
    public void visit(ExternalClause n) throws Exception {
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeToken.accept(this);
    }

    /**
     * <PRE>
     * nodeOptional -&gt; [ &lt;IS&gt; ]
     * nodeToken -&gt; &lt;GLOBAL&gt;
     * </PRE>
     */
    public void visit(GlobalClause n) throws Exception {
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeToken.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;BLOCK&gt;
     * nodeOptional -&gt; [ &lt;CONTAINS&gt; ]
     * nodeOptional1 -&gt; [ IntegerConstant() &lt;TO&gt; ]
     * integerConstant -&gt; IntegerConstant()
     * nodeOptional2 -&gt; [ &lt;RECORDS&gt; | &lt;CHARACTERS&gt; ]
     * </PRE>
     */
    public void visit(BlockContainsClause n) throws Exception {
        n.nodeToken.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        n.integerConstant.accept(this);
        if (n.nodeOptional2.present()) {
            n.nodeOptional2.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;RECORD&gt;
     * nodeOptional -&gt; [ &lt;CONTAINS&gt; ]
     * nodeChoice -&gt; ( [ IntegerConstant() &lt;TO&gt; ] IntegerConstant() [ &lt;CHARACTERS&gt; ] | [ &lt;IS&gt; ] &lt;VARYING&gt; [ &lt;IN&gt; ] [ &lt;SIZE&gt; ] [ [ &lt;FROM&gt; ] IntegerConstant() [ &lt;TO&gt; IntegerConstant() ] [ &lt;CHARACTERS&gt; ] ] [ &lt;DEPENDING&gt; [ &lt;ON&gt; ] QualifiedDataName() ] )
     * </PRE>
     */
    public void visit(RecordContainsClause n) throws Exception {
        n.nodeToken.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;LABEL&gt;
     * nodeChoice -&gt; ( &lt;RECORD&gt; [ &lt;IS&gt; ] | &lt;RECORDS&gt; [ &lt;ARE&gt; ] )
     * nodeChoice1 -&gt; ( &lt;OMITTED&gt; | &lt;STANDARD&gt; | ( DataName() )+ )
     * </PRE>
     */
    public void visit(LabelRecordsClause n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeChoice.accept(this);
        n.nodeChoice1.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;VALUE&gt;
     * nodeToken1 -&gt; &lt;OF&gt;
     * nodeList -&gt; ( SystemName() &lt;IS&gt; ( QualifiedDataName() | Literal() ) )+
     * </PRE>
     */
    public void visit(ValueOfClause n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
        processList(n.nodeList);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;DATA&gt;
     * nodeChoice -&gt; ( &lt;RECORD&gt; [ &lt;IS&gt; ] | &lt;RECORDS&gt; [ &lt;ARE&gt; ] )
     * nodeList -&gt; ( DataName() [ &lt;COMMACHAR&gt; ] )+
     * </PRE>
     */
    public void visit(DataRecordClause n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeChoice.accept(this);
        processList(n.nodeList);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;LINAGE&gt;
     * nodeOptional -&gt; [ &lt;IS&gt; ]
     * nodeChoice -&gt; ( DataName() | IntegerConstant() )
     * nodeOptional1 -&gt; [ &lt;LINES&gt; ]
     * nodeListOptional -&gt; ( [ &lt;WITH&gt; ] &lt;FOOTING&gt; [ &lt;AT&gt; ] ( DataName() | IntegerConstant() ) | [ &lt;LINES&gt; ] [ &lt;AT&gt; ] &lt;TOP&gt; ( DataName() | IntegerConstant() ) | [ &lt;LINES&gt; ] [ &lt;AT&gt; ] &lt;BOTTOM&gt; ( DataName() | IntegerConstant() ) )*
     * </PRE>
     */
    public void visit(LinageClause n) throws Exception {
        n.nodeToken.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeChoice.accept(this);
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;RECORDING&gt;
     * nodeOptional -&gt; [ &lt;MODE&gt; ]
     * nodeOptional1 -&gt; [ &lt;IS&gt; ]
     * mode -&gt; Mode()
     * </PRE>
     */
    public void visit(RecordingModeClause n) throws Exception {
        n.nodeToken.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        n.mode.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;CODE_SET&gt;
     * nodeOptional -&gt; [ &lt;IS&gt; ]
     * alphabetName -&gt; AlphabetName()
     * </PRE>
     */
    public void visit(CodeSetClause n) throws Exception {
        n.nodeToken.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.alphabetName.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( &lt;REPORT&gt; [ &lt;IS&gt; ] | &lt;REPORTS&gt; [ &lt;ARE&gt; ] )
     * nodeList -&gt; ( QualifiedDataName() )+
     * </PRE>
     */
    public void visit(ReportClause n) throws Exception {
        n.nodeChoice.accept(this);
        processList(n.nodeList);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( LevelNumber() ( DataName() | &lt;FILLER&gt; )? ( DataDescriptionEntryClause() )* &lt;DOT&gt; | &lt;LEVEL_66&gt; DataName() RenamesClause() &lt;DOT&gt; | &lt;LEVEL_77&gt; DataName() ( DataDescriptionEntryClause() )* &lt;DOT&gt; | &lt;LEVEL_78&gt; ConditionName() ConditionValueClause() &lt;DOT&gt; | &lt;LEVEL_88&gt; ConditionName() ConditionValueClause() &lt;DOT&gt; | ( &lt;EXEC&gt; | &lt;EXECUTE&gt; ) &lt;K_SQL&gt; ( &lt;K_INCLUDE&gt; ( &lt;S_IDENTIFIER&gt; | &lt;S_QUOTED_IDENTIFIER&gt; ) &lt;DOT&gt; | &lt;K_BEGIN&gt; &lt;K_DECLARE&gt; &lt;K_SECTION&gt; &lt;END_EXEC&gt; &lt;DOT&gt; | &lt;K_END&gt; &lt;K_DECLARE&gt; &lt;K_SECTION&gt; &lt;END_EXEC&gt; &lt;DOT&gt; | DeclareCursorStatement() &lt;END_EXEC&gt; &lt;DOT&gt; ) )
     * </PRE>
     */
    public void visit(DataDescriptionEntry n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeOptional -&gt; [ &lt;COMMACHAR&gt; ]
     * nodeChoice -&gt; ( DataPictureClause() | DataValueClause() | DataUsageClause() | DataRedefinesClause() | DataExternalClause() | DataGlobalClause() | DataSignClause() | DataOccursClause() | DataSynchronizedClause() | DataJustifiedClause() | DataBlankWhenZeroClause() )
     * nodeOptional1 -&gt; [ &lt;COMMACHAR&gt; ]
     * </PRE>
     */
    public void visit(DataDescriptionEntryClause n) throws Exception {
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeChoice.accept(this);
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;REDEFINES&gt;
     * dataName -&gt; DataName()
     * </PRE>
     */
    public void visit(DataRedefinesClause n) throws Exception {
        n.nodeToken.accept(this);
        n.dataName.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;BLANK&gt;
     * nodeOptional -&gt; [ &lt;WHEN&gt; ]
     * nodeChoice -&gt; ( &lt;ZERO&gt; | &lt;ZEROS&gt; | &lt;ZEROES&gt; )
     * </PRE>
     */
    public void visit(DataBlankWhenZeroClause n) throws Exception {
        n.nodeToken.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( &lt;JUSTIFIED&gt; | &lt;JUST&gt; )
     * nodeOptional -&gt; [ &lt;RIGHT&gt; ]
     * </PRE>
     */
    public void visit(DataJustifiedClause n) throws Exception {
        n.nodeChoice.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;OCCURS&gt;
     * nodeOptional -&gt; [ ( IntegerConstant() | DataName() ) &lt;TO&gt; ]
     * nodeChoice -&gt; ( IntegerConstant() | DataName() )
     * nodeOptional1 -&gt; [ &lt;TIMES&gt; ]
     * nodeOptional2 -&gt; [ &lt;DEPENDING&gt; [ &lt;ON&gt; ] QualifiedDataName() ]
     * nodeListOptional -&gt; ( ( &lt;ASCENDING&gt; | &lt;DESCENDING&gt; ) [ &lt;KEY&gt; ] [ &lt;IS&gt; ] ( QualifiedDataName() )+ )*
     * nodeOptional3 -&gt; [ &lt;INDEXED&gt; [ &lt;BY&gt; ] ( IndexName() [ &lt;COMMACHAR&gt; ] )+ ]
     * </PRE>
     */
    public void visit(DataOccursClause n) throws Exception {
        n.nodeToken.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeChoice.accept(this);
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        if (n.nodeOptional2.present()) {
            n.nodeOptional2.accept(this);
        }
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
        if (n.nodeOptional3.present()) {
            n.nodeOptional3.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( &lt;PICTURE&gt; | &lt;PIC&gt; )
     * nodeOptional -&gt; [ &lt;IS&gt; ]
     * pictureString -&gt; PictureString()
     * nodeOptional1 -&gt; [ &lt;VARYING&gt; ]
     * </PRE>
     */
    public void visit(DataPictureClause n) throws Exception {
        n.nodeChoice.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.pictureString.accept(this);
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
    }

    /**
     * <PRE>
     * pictureOccurence -&gt; PictureOccurence()
     * nodeListOptional -&gt; ( &lt;DOTCHAR&gt; PictureOccurence() | PictureOccurence() )*
     * nodeListOptional1 -&gt; ( &lt;DOTCHAR&gt; )*
     * </PRE>
     */
    public void visit(PictureString n) throws Exception {
        n.pictureOccurence.accept(this);
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
        if (n.nodeListOptional1.present()) {
            processList(n.nodeListOptional1);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( NonDotChars() )+ [ &lt;LPARENCHAR&gt; ( IntegerConstant() | DataName() ) &lt;RPARENCHAR&gt; ]
     *       | &lt;DOTCHAR&gt; ( &lt;LPARENCHAR&gt; ( IntegerConstant() | DataName() ) &lt;RPARENCHAR&gt; | NonDotChars() )
     * </PRE>
     */
    public void visit(PictureOccurence n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; &lt;SLASHCHAR&gt;
     *       | &lt;COMMACHAR&gt;
     *       | &lt;COLONCHAR&gt;
     *       | &lt;ASTERISKCHAR&gt;
     *       | &lt;MINUSCHAR&gt;
     *       | &lt;PLUSCHAR&gt;
     *       | &lt;POW&gt;
     *       | &lt;LESSTHANOREQUAL&gt;
     *       | &lt;LESSTHANCHAR&gt;
     *       | &lt;MORETHANOREQUAL&gt;
     *       | &lt;MORETHANCHAR&gt;
     *       | &lt;EQUALCHAR&gt;
     *       | &lt;NOTEQUALCHAR&gt;
     * </PRE>
     */
    public void visit(PicturePunctuation n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;DOLLARCHAR&gt;
     * </PRE>
     */
    public void visit(PictureCurrency n) throws Exception {
        n.nodeToken.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; IntegerConstant()
     *       | CobolWord()
     *       | PicturePunctuation()
     *       | PictureCurrency()
     * </PRE>
     */
    public void visit(NonDotChars n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeOptional -&gt; [ &lt;IS&gt; ]
     * nodeToken -&gt; &lt;EXTERNAL&gt;
     * </PRE>
     */
    public void visit(DataExternalClause n) throws Exception {
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeToken.accept(this);
    }

    /**
     * <PRE>
     * nodeOptional -&gt; [ &lt;IS&gt; ]
     * nodeToken -&gt; &lt;GLOBAL&gt;
     * </PRE>
     */
    public void visit(DataGlobalClause n) throws Exception {
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeToken.accept(this);
    }

    /**
     * <PRE>
     * nodeOptional -&gt; [ &lt;USAGE&gt; [ &lt;IS&gt; ] ]
     * nodeChoice -&gt; ( &lt;BINARY&gt; | &lt;COMP&gt; | &lt;COMP_1&gt; | &lt;COMP_2&gt; | &lt;COMP_3&gt; | &lt;COMP_4&gt; | &lt;COMP_5&gt; | &lt;COMPUTATIONAL&gt; | &lt;COMPUTATIONAL_1&gt; | &lt;COMPUTATIONAL_2&gt; | &lt;COMPUTATIONAL_3&gt; | &lt;COMPUTATIONAL_4&gt; | &lt;COMPUTATIONAL_5&gt; | &lt;DISPLAY&gt; | &lt;DISPLAY_1&gt; | &lt;INDEX&gt; | &lt;PACKED_DECIMAL&gt; | &lt;POINTER&gt; | &lt;FUNCTION_POINTER&gt; | &lt;PROCEDURE_POINTER&gt; | &lt;OBJECT&gt; &lt;REFERENCE&gt; DataName() )
     * </PRE>
     */
    public void visit(DataUsageClause n) throws Exception {
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeOptional -&gt; [ &lt;SIGN&gt; [ &lt;IS&gt; ] ]
     * nodeChoice -&gt; ( &lt;LEADING&gt; | &lt;TRAILING&gt; )
     * nodeOptional1 -&gt; [ &lt;SEPARATE&gt; [ &lt;CHARACTER&gt; ] ]
     * </PRE>
     */
    public void visit(DataSignClause n) throws Exception {
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeChoice.accept(this);
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( &lt;SYNCHRONIZED&gt; | &lt;SYNC&gt; )
     * nodeOptional -&gt; [ ( &lt;LEFT&gt; | &lt;RIGHT&gt; ) ]
     * </PRE>
     */
    public void visit(DataSynchronizedClause n) throws Exception {
        n.nodeChoice.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( &lt;VALUE&gt; [ &lt;IS&gt; ] | &lt;VALUES&gt; [ &lt;ARE&gt; ] )
     * nodeList -&gt; ( ( Identifier() | Literal() ) [ &lt;COMMACHAR&gt; ] [ ( &lt;THROUGH&gt; | &lt;THRU&gt; ) Literal() [ &lt;COMMACHAR&gt; ] ] )+
     * </PRE>
     */
    public void visit(DataValueClause n) throws Exception {
        n.nodeChoice.accept(this);
        processList(n.nodeList);
    }

    /**
     * <PRE>
     * dataValueClause -&gt; DataValueClause()
     * </PRE>
     */
    public void visit(ConditionValueClause n) throws Exception {
        n.dataValueClause.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;RENAMES&gt;
     * qualifiedDataName -&gt; QualifiedDataName()
     * nodeOptional -&gt; [ ( &lt;THROUGH&gt; | &lt;THRU&gt; ) QualifiedDataName() ]
     * </PRE>
     */
    public void visit(RenamesClause n) throws Exception {
        n.nodeToken.accept(this);
        n.qualifiedDataName.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;WORKING_STORAGE&gt;
     * nodeToken1 -&gt; &lt;SECTION&gt;
     * nodeToken2 -&gt; &lt;DOT&gt;
     * nodeListOptional -&gt; ( DataDescriptionEntry() )*
     * </PRE>
     */
    public void visit(WorkingStorageSection n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
        n.nodeToken2.accept(this);
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;LINKAGE&gt;
     * nodeToken1 -&gt; &lt;SECTION&gt;
     * nodeToken2 -&gt; &lt;DOT&gt;
     * nodeListOptional -&gt; ( DataDescriptionEntry() )*
     * </PRE>
     */
    public void visit(LinkageSection n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
        n.nodeToken2.accept(this);
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( &lt;PROCEDURE&gt; &lt;DIVISION&gt; | &lt;PROCEDURE_DIVISION&gt; )
     * nodeOptional -&gt; [ [ &lt;DOT&gt; ] UsingArgs() ]
     * nodeToken -&gt; &lt;DOT&gt;
     * nodeOptional1 -&gt; [ Declaratives() ]
     * procedureBody -&gt; ProcedureBody()
     * </PRE>
     */
    public void visit(ProcedureDivision n) throws Exception {
        n.nodeChoice.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeToken.accept(this);
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        n.procedureBody.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;USING&gt;
     * nodeList -&gt; ( [ [ &lt;BY&gt; ] ( &lt;REFERENCE&gt; | &lt;VALUE&gt; ) ] QualifiedDataName() [ &lt;COMMACHAR&gt; ] )+
     * </PRE>
     */
    public void visit(UsingArgs n) throws Exception {
        n.nodeToken.accept(this);
        processList(n.nodeList);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;DECLARATIVES&gt;
     * nodeToken1 -&gt; &lt;DOT&gt;
     * nodeList -&gt; ( SectionHeader() &lt;DOT&gt; UseStatement() &lt;DOT&gt; Paragraphs() )+
     * nodeToken2 -&gt; &lt;END&gt;
     * nodeToken3 -&gt; &lt;DECLARATIVES&gt;
     * nodeToken4 -&gt; &lt;DOT&gt;
     * </PRE>
     */
    public void visit(Declaratives n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
        processList(n.nodeList);
        n.nodeToken2.accept(this);
        n.nodeToken3.accept(this);
        n.nodeToken4.accept(this);
    }

    /**
     * <PRE>
     * paragraphs -&gt; Paragraphs()
     * nodeListOptional -&gt; ( ProcedureSection() )*
     * </PRE>
     */
    public void visit(ProcedureBody n) throws Exception {
        n.paragraphs.accept(this);
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
    }

    /**
     * <PRE>
     * sectionHeader -&gt; SectionHeader()
     * nodeToken -&gt; &lt;DOT&gt;
     * paragraphs -&gt; Paragraphs()
     * </PRE>
     */
    public void visit(ProcedureSection n) throws Exception {
        n.sectionHeader.accept(this);
        n.nodeToken.accept(this);
        n.paragraphs.accept(this);
    }

    /**
     * <PRE>
     * sectionName -&gt; SectionName()
     * nodeToken -&gt; &lt;SECTION&gt;
     * nodeOptional -&gt; [ IntegerConstant() ]
     * </PRE>
     */
    public void visit(SectionHeader n) throws Exception {
        n.sectionName.accept(this);
        n.nodeToken.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeListOptional -&gt; ( Sentence() )*
     * nodeListOptional1 -&gt; ( Paragraph() )*
     * </PRE>
     */
    public void visit(Paragraphs n) throws Exception {
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
        if (n.nodeListOptional1.present()) {
            processList(n.nodeListOptional1);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( ParagraphName() | EntryStatement() )
     * nodeToken -&gt; &lt;DOT&gt;
     * nodeChoice1 -&gt; ( ExitProgramStatement() &lt;DOT&gt; | ExitStatement() &lt;DOT&gt; | AlteredGoto() | ( Sentence() )* )
     * </PRE>
     */
    public void visit(Paragraph n) throws Exception {
        n.nodeChoice.accept(this);
        n.nodeToken.accept(this);
        n.nodeChoice1.accept(this);
    }

    /**
     * <PRE>
     * nodeList -&gt; ( Statement() )+
     * nodeToken -&gt; &lt;DOT&gt;
     * </PRE>
     */
    public void visit(Sentence n) throws Exception {
        processList(n.nodeList);
        n.nodeToken.accept(this);
    }

    /**
     * <PRE>
     * nodeList -&gt; ( Statement() )+
     * </PRE>
     */
    public void visit(StatementList n) throws Exception {
        processList(n.nodeList);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( AcceptStatement() | AddStatement() | AlterStatement() | CallStatement() | CancelStatement() | CloseStatement() | ComputeStatement() | ContinueStatement() | DeleteStatement() | DisplayStatement() | DivideStatement() | EvaluateStatement() | ExitProgramStatement() | ExitStatement() | GobackStatement() | GotoStatement() | IfStatement() | InitializeStatement() | InspectStatement() | MergeStatement() | MoveStatement() | MultiplyStatement() | OpenStatement() | PerformStatement() | ReadStatement() | ReleaseStatement() | ReturnStatement() | RewriteStatement() | SearchStatement() | SetStatement() | SortStatement() | StartStatement() | StopStatement() | StringStatement() | SubtractStatement() | UnstringStatement() | WriteStatement() | ExecSqlStatement() | EnableStatement() | DisableStatement() | ReceiveStatement() | SendStatement() )
     * nodeOptional -&gt; [ &lt;COMMACHAR&gt; ]
     * </PRE>
     */
    public void visit(Statement n) throws Exception {
        n.nodeChoice.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;ENABLE&gt;
     * nodeChoice -&gt; ( &lt;INPUT&gt; [ &lt;TERMINAL&gt; ] | &lt;OUTPUT&gt; )
     * nodeChoice1 -&gt; ( Identifier() | Literal() )
     * nodeOptional -&gt; [ &lt;WITH&gt; ]
     * nodeToken1 -&gt; &lt;KEY&gt;
     * nodeChoice2 -&gt; ( Identifier() | Literal() )
     * </PRE>
     */
    public void visit(EnableStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeChoice.accept(this);
        n.nodeChoice1.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeToken1.accept(this);
        n.nodeChoice2.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;DISABLE&gt;
     * nodeChoice -&gt; ( &lt;INPUT&gt; [ &lt;TERMINAL&gt; ] | &lt;OUTPUT&gt; )
     * nodeChoice1 -&gt; ( Identifier() | Literal() )
     * nodeOptional -&gt; [ &lt;WITH&gt; ]
     * nodeToken1 -&gt; &lt;KEY&gt;
     * nodeChoice2 -&gt; ( Identifier() | Literal() )
     * </PRE>
     */
    public void visit(DisableStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeChoice.accept(this);
        n.nodeChoice1.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeToken1.accept(this);
        n.nodeChoice2.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;RECEIVE&gt;
     * nodeChoice -&gt; ( Identifier() | Literal() )
     * nodeChoice1 -&gt; ( &lt;MESSAGE&gt; | &lt;SEGMENT&gt; )
     * nodeToken1 -&gt; &lt;INTO&gt;
     * identifier -&gt; Identifier()
     * nodeOptional -&gt; [ &quot;;&quot; | &lt;NO&gt; &lt;DATA&gt; Statement() ]
     * </PRE>
     */
    public void visit(ReceiveStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeChoice.accept(this);
        n.nodeChoice1.accept(this);
        n.nodeToken1.accept(this);
        n.identifier.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;SEND&gt;
     * nodeChoice -&gt; ( Identifier() | Literal() )
     * nodeOptional -&gt; [ &lt;FROM&gt; Identifier() ]
     * nodeOptional1 -&gt; [ &lt;WITH&gt; ( Identifier() | &lt;ESI&gt; | &lt;EMI&gt; | &lt;EGI&gt; ) ]
     * nodeOptional2 -&gt; [ ( &lt;BEFORE&gt; | &lt;AFTER&gt; ) [ &lt;ADVANCING&gt; ] ( ( ( Identifier() | Literal() ) [ &lt;LINE&gt; | &lt;LINES&gt; ] ) | ( MnemonicName() | &lt;PAGE&gt; ) ) ]
     * </PRE>
     */
    public void visit(SendStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeChoice.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        if (n.nodeOptional2.present()) {
            n.nodeOptional2.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( &lt;EXEC&gt; | &lt;EXECUTE&gt; )
     * nodeToken -&gt; &lt;K_SQL&gt;
     * nodeChoice1 -&gt; ( &lt;K_WHENEVER&gt; ( &lt;K_NOT&gt; &lt;K_FOUND&gt; | &lt;K_SQLERROR&gt; | &lt;K_SQLWARNING&gt; ) Statement() | ( ( SQLStatement() | DeclareCursorStatement() | &lt;K_PREPARE&gt; &lt;S_IDENTIFIER&gt; &lt;K_FROM&gt; &lt;S_BIND&gt; | &lt;K_ALTER&gt; &lt;K_SESSION&gt; SQLSetStatement() | &lt;K_EXECUTE&gt; SkipToEndExec() | &lt;K_CONNECT&gt; &lt;S_BIND&gt; | SkipToEndExec() ) &lt;END_EXEC&gt; ) )
     * </PRE>
     */
    public void visit(ExecSqlStatement n) throws Exception {
        n.nodeChoice.accept(this);
        n.nodeToken.accept(this);
        n.nodeChoice1.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;K_DECLARE&gt;
     * nodeToken1 -&gt; &lt;S_IDENTIFIER&gt;
     * nodeToken2 -&gt; &lt;K_CURSOR&gt;
     * nodeToken3 -&gt; &lt;K_FOR&gt;
     * nodeChoice -&gt; ( &lt;S_IDENTIFIER&gt; | QueryStatement() )
     * </PRE>
     */
    public void visit(DeclareCursorStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
        n.nodeToken2.accept(this);
        n.nodeToken3.accept(this);
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;ACCEPT&gt;
     * identifier -&gt; Identifier()
     * nodeOptional -&gt; [ &lt;FROM&gt; ( MnemonicName() | EnvironmentName() | &lt;DATE&gt; [ &lt;COBOL_WORD&gt; ] | &lt;DAY&gt; [ &lt;COBOL_WORD&gt; ] | &lt;DAY_OF_WEEK&gt; | &lt;TIME&gt; ) | [ &lt;MESSAGE&gt; ] &lt;COUNT&gt; ]
     * </PRE>
     */
    public void visit(AcceptStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.identifier.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;ADD&gt;
     * addBody -&gt; AddBody()
     * nodeOptional -&gt; [ [ &lt;ON&gt; ] &lt;SIZE&gt; &lt;ERROR&gt; StatementList() ]
     * nodeOptional1 -&gt; [ &lt;NOT&gt; [ &lt;ON&gt; ] &lt;SIZE&gt; &lt;ERROR&gt; StatementList() ]
     * nodeOptional2 -&gt; [ &lt;END_ADD&gt; ]
     * </PRE>
     */
    public void visit(AddStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.addBody.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        if (n.nodeOptional2.present()) {
            n.nodeOptional2.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; IdOrLiteralList() [ &lt;TO&gt; IdOrLiteral() ] &lt;GIVING&gt; ArithIdentifierList()
     *       | IdOrLiteralList() &lt;TO&gt; ArithIdentifierList()
     *       | ( &lt;CORRESPONDING&gt; | &lt;CORR&gt; ) Identifier() &lt;TO&gt; Identifier() [ &lt;ROUNDED&gt; ]
     * </PRE>
     */
    public void visit(AddBody n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * identifier -&gt; Identifier()
     * nodeOptional -&gt; [ &lt;ROUNDED&gt; ]
     * </PRE>
     */
    public void visit(ArithIdentifier n) throws Exception {
        n.identifier.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeList -&gt; ( ArithIdentifier() [ &lt;COMMACHAR&gt; ] )+
     * </PRE>
     */
    public void visit(ArithIdentifierList n) throws Exception {
        processList(n.nodeList);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; Identifier()
     *       | Literal()
     * </PRE>
     */
    public void visit(IdOrLiteral n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeList -&gt; ( IdOrLiteral() [ &lt;COMMACHAR&gt; ] )+
     * </PRE>
     */
    public void visit(IdOrLiteralList n) throws Exception {
        processList(n.nodeList);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;GO&gt;
     * nodeOptional -&gt; [ &lt;TO&gt; ]
     * nodeToken1 -&gt; &lt;DOT&gt;
     * </PRE>
     */
    public void visit(AlteredGoto n) throws Exception {
        n.nodeToken.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeToken1.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;ALTER&gt;
     * nodeList -&gt; ( ProcedureName() &lt;TO&gt; [ &lt;PROCEED&gt; &lt;TO&gt; ] ProcedureName() [ &lt;COMMACHAR&gt; ] )+
     * </PRE>
     */
    public void visit(AlterStatement n) throws Exception {
        n.nodeToken.accept(this);
        processList(n.nodeList);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;CALL&gt;
     * nodeChoice -&gt; ( Identifier() | Literal() )
     * nodeOptional -&gt; [ &lt;USING&gt; ( ( [ [ &lt;BY&gt; ] &lt;REFERENCE&gt; ] ( CallByReferenceArgs() [ &lt;COMMACHAR&gt; ] )+ | [ &lt;BY&gt; ] ( &lt;CONTENT&gt; | &lt;VALUE&gt; ) ( CallByContentArgs() [ &lt;COMMACHAR&gt; ] )+ ) )+ ]
     * nodeOptional1 -&gt; [ [ &lt;ON&gt; ] &lt;OVERFLOW&gt; StatementList() ]
     * nodeOptional2 -&gt; [ [ &lt;ON&gt; ] &lt;EXCEPTION&gt; StatementList() ]
     * nodeOptional3 -&gt; [ &lt;NOT&gt; [ &lt;ON&gt; ] &lt;EXCEPTION&gt; StatementList() ]
     * nodeOptional4 -&gt; [ &lt;END_CALL&gt; ]
     * </PRE>
     */
    public void visit(CallStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeChoice.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        if (n.nodeOptional2.present()) {
            n.nodeOptional2.accept(this);
        }
        if (n.nodeOptional3.present()) {
            n.nodeOptional3.accept(this);
        }
        if (n.nodeOptional4.present()) {
            n.nodeOptional4.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; Identifier()
     *       | &lt;ADDRESS&gt; &lt;OF&gt; Identifier()
     *       | FileName()
     * </PRE>
     */
    public void visit(CallByReferenceArgs n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; [ &lt;LENGTH&gt; &lt;OF&gt; ] Identifier()
     *       | &lt;ADDRESS&gt; &lt;OF&gt; Identifier()
     *       | Literal()
     * </PRE>
     */
    public void visit(CallByContentArgs n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;CANCEL&gt;
     * nodeList -&gt; ( ( Identifier() | Literal() ) [ &lt;COMMACHAR&gt; ] )+
     * </PRE>
     */
    public void visit(CancelStatement n) throws Exception {
        n.nodeToken.accept(this);
        processList(n.nodeList);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;CLOSE&gt;
     * nodeList -&gt; ( FileName() [ ( ( &lt;REEL&gt; | &lt;UNIT&gt; ) [ ( [ &lt;FOR&gt; ] &lt;REMOVAL&gt; | [ &lt;WITH&gt; ] &lt;NO&gt; &lt;REWIND&gt; ) ] | [ &lt;WITH&gt; ] ( &lt;NO&gt; &lt;REWIND&gt; | &lt;LOCK&gt; ) ) ] [ &lt;COMMACHAR&gt; ] )+
     * </PRE>
     */
    public void visit(CloseStatement n) throws Exception {
        n.nodeToken.accept(this);
        processList(n.nodeList);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;COMPUTE&gt;
     * nodeList -&gt; ( Identifier() [ &lt;ROUNDED&gt; ] )+
     * nodeChoice -&gt; ( &lt;EQUALCHAR&gt; | &lt;EQUAL&gt; )
     * arithmeticExpression -&gt; ArithmeticExpression()
     * nodeOptional -&gt; [ [ &lt;ON&gt; ] &lt;SIZE&gt; &lt;ERROR&gt; StatementList() ]
     * nodeOptional1 -&gt; [ &lt;NOT&gt; [ &lt;ON&gt; ] &lt;SIZE&gt; &lt;ERROR&gt; StatementList() ]
     * nodeOptional2 -&gt; [ &lt;END_COMPUTE&gt; ]
     * </PRE>
     */
    public void visit(ComputeStatement n) throws Exception {
        n.nodeToken.accept(this);
        processList(n.nodeList);
        n.nodeChoice.accept(this);
        n.arithmeticExpression.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        if (n.nodeOptional2.present()) {
            n.nodeOptional2.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;CONTINUE&gt;
     * </PRE>
     */
    public void visit(ContinueStatement n) throws Exception {
        n.nodeToken.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;DELETE&gt;
     * fileName -&gt; FileName()
     * nodeOptional -&gt; [ &lt;RECORD&gt; ]
     * nodeOptional1 -&gt; [ &lt;INVALID&gt; [ &lt;KEY&gt; ] StatementList() ]
     * nodeOptional2 -&gt; [ &lt;NOT&gt; &lt;INVALID&gt; [ &lt;KEY&gt; ] StatementList() ]
     * nodeOptional3 -&gt; [ &lt;END_DELETE&gt; ]
     * </PRE>
     */
    public void visit(DeleteStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.fileName.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        if (n.nodeOptional2.present()) {
            n.nodeOptional2.accept(this);
        }
        if (n.nodeOptional3.present()) {
            n.nodeOptional3.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;DISPLAY&gt;
     * nodeList -&gt; ( ( Identifier() | Literal() ) [ &lt;COMMACHAR&gt; ] )+
     * nodeOptional -&gt; [ &lt;UPON&gt; ( MnemonicName() | EnvironmentName() ) ]
     * nodeOptional1 -&gt; [ [ &lt;WITH&gt; ] &lt;NO&gt; &lt;ADVANCING&gt; ]
     * </PRE>
     */
    public void visit(DisplayStatement n) throws Exception {
        n.nodeToken.accept(this);
        processList(n.nodeList);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;DIVIDE&gt;
     * divideBody -&gt; DivideBody()
     * nodeOptional -&gt; [ [ &lt;ON&gt; ] &lt;SIZE&gt; &lt;ERROR&gt; StatementList() ]
     * nodeOptional1 -&gt; [ &lt;NOT&gt; [ &lt;ON&gt; ] &lt;SIZE&gt; &lt;ERROR&gt; StatementList() ]
     * nodeOptional2 -&gt; [ &lt;END_DIVIDE&gt; ]
     * </PRE>
     */
    public void visit(DivideStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.divideBody.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        if (n.nodeOptional2.present()) {
            n.nodeOptional2.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( IdOrLiteral() &lt;INTO&gt; ( IdOrLiteral() | ArithIdentifierList() ) [ &lt;GIVING&gt; ArithIdentifierList() [ &lt;REMAINDER&gt; ArithIdentifier() ] ] | IdOrLiteral() &lt;BY&gt; IdOrLiteral() &lt;GIVING&gt; ArithIdentifierList() [ &lt;REMAINDER&gt; ArithIdentifier() ] )
     * </PRE>
     */
    public void visit(DivideBody n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;ENTRY&gt;
     * literal -&gt; Literal()
     * nodeOptional -&gt; [ UsingArgs() ]
     * </PRE>
     */
    public void visit(EntryStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.literal.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;EVALUATE&gt;
     * evaluateValue -&gt; EvaluateValue()
     * nodeListOptional -&gt; ( &lt;ALSO&gt; EvaluateValue() )*
     * nodeList -&gt; ( ( &lt;WHEN&gt; [ &lt;EQUALCHAR&gt; ] EvaluatePhrase() ( &lt;ALSO&gt; EvaluatePhrase() )* )+ StatementList() )+
     * nodeOptional -&gt; [ &lt;WHEN&gt; &lt;OTHER&gt; StatementList() ]
     * nodeOptional1 -&gt; [ &lt;END_EVALUATE&gt; ]
     * </PRE>
     */
    public void visit(EvaluateStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.evaluateValue.accept(this);
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
        processList(n.nodeList);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( Identifier() | Condition() | ArithmeticExpression() | Literal() | &lt;TRUE&gt; | &lt;FALSE&gt; )
     * </PRE>
     */
    public void visit(EvaluateValue n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( &lt;ANY&gt; | [ &lt;NOT&gt; ] ( Identifier() | Literal() | ArithmeticExpression() ) [ ( &lt;THROUGH&gt; | &lt;THRU&gt; ) ( Identifier() | Literal() | ArithmeticExpression() ) ] | Condition() | &lt;TRUE&gt; | &lt;FALSE&gt; )
     * </PRE>
     */
    public void visit(EvaluatePhrase n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;EXIT&gt;
     * </PRE>
     */
    public void visit(ExitStatement n) throws Exception {
        n.nodeToken.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;EXIT&gt;
     * nodeToken1 -&gt; &lt;PROGRAM&gt;
     * </PRE>
     */
    public void visit(ExitProgramStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;GOBACK&gt;
     * </PRE>
     */
    public void visit(GobackStatement n) throws Exception {
        n.nodeToken.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;GO&gt;
     * nodeOptional -&gt; [ &lt;TO&gt; ]
     * nodeChoice -&gt; ( ProcedureName() [ ( ProcedureName() )* &lt;DEPENDING&gt; [ &lt;ON&gt; ] Identifier() ] | &lt;MORE_LABELS&gt; )
     * </PRE>
     */
    public void visit(GotoStatement n) throws Exception {
        n.nodeToken.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;IF&gt;
     * condition -&gt; Condition()
     * nodeOptional -&gt; [ &lt;THEN&gt; ]
     * nodeChoice -&gt; ( StatementList() [ &lt;NEXT&gt; &lt;SENTENCE&gt; ] | &lt;NEXT&gt; &lt;SENTENCE&gt; )
     * nodeOptional1 -&gt; [ &lt;ELSE&gt; ( StatementList() [ &lt;NEXT&gt; &lt;SENTENCE&gt; ] | &lt;NEXT&gt; &lt;SENTENCE&gt; ) ]
     * nodeOptional2 -&gt; [ &lt;END_IF&gt; ]
     * </PRE>
     */
    public void visit(IfStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.condition.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeChoice.accept(this);
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        if (n.nodeOptional2.present()) {
            n.nodeOptional2.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;INITIALIZE&gt;
     * nodeList -&gt; ( Identifier() [ &lt;COMMACHAR&gt; ] )+
     * nodeOptional -&gt; [ &lt;REPLACING&gt; ( ( &lt;ALPHABETIC&gt; | &lt;ALPHANUMERIC&gt; | &lt;NUMERIC&gt; | &lt;ALPHANUMERIC_EDITED&gt; | &lt;NUMERIC_EDITED&gt; | &lt;DBCS&gt; | &lt;EGCS&gt; ) [ &lt;DATA&gt; ] &lt;BY&gt; ( Identifier() | Literal() [ &lt;COMMACHAR&gt; ] ) )+ ]
     * </PRE>
     */
    public void visit(InitializeStatement n) throws Exception {
        n.nodeToken.accept(this);
        processList(n.nodeList);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;INSPECT&gt;
     * identifier -&gt; Identifier()
     * nodeChoice -&gt; ( TallyingPhrase() | ConvertingPhrase() | ReplacingPhrase() )
     * </PRE>
     */
    public void visit(InspectStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.identifier.accept(this);
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;TALLYING&gt;
     * nodeList -&gt; ( Identifier() &lt;FOR&gt; ( &lt;CHARACTERS&gt; ( BeforeAfterPhrase() )* | ( &lt;ALL&gt; | &lt;LEADING&gt; ) ( ( Identifier() | Literal() ) ( BeforeAfterPhrase() )* )+ )+ )+
     * nodeOptional -&gt; [ ReplacingPhrase() ]
     * </PRE>
     */
    public void visit(TallyingPhrase n) throws Exception {
        n.nodeToken.accept(this);
        processList(n.nodeList);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;CONVERTING&gt;
     * nodeChoice -&gt; ( Identifier() | Literal() )
     * nodeToken1 -&gt; &lt;TO&gt;
     * nodeChoice1 -&gt; ( Identifier() | Literal() )
     * nodeListOptional -&gt; ( BeforeAfterPhrase() )*
     * </PRE>
     */
    public void visit(ConvertingPhrase n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeChoice.accept(this);
        n.nodeToken1.accept(this);
        n.nodeChoice1.accept(this);
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;REPLACING&gt;
     * nodeList -&gt; ( &lt;CHARACTERS&gt; &lt;BY&gt; ( Identifier() | Literal() ) ( BeforeAfterPhrase() )* | ( &lt;ALL&gt; | &lt;LEADING&gt; | &lt;FIRST&gt; ) ( ( Identifier() | Literal() ) &lt;BY&gt; ( Identifier() | Literal() ) ( BeforeAfterPhrase() )* )+ )+
     * </PRE>
     */
    public void visit(ReplacingPhrase n) throws Exception {
        n.nodeToken.accept(this);
        processList(n.nodeList);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( &lt;BEFORE&gt; | &lt;AFTER&gt; )
     * nodeOptional -&gt; [ &lt;INITIAL&gt; ]
     * nodeChoice1 -&gt; ( Identifier() | Literal() )
     * </PRE>
     */
    public void visit(BeforeAfterPhrase n) throws Exception {
        n.nodeChoice.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeChoice1.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;MERGE&gt;
     * fileName -&gt; FileName()
     * nodeList -&gt; ( [ &lt;ON&gt; ] ( &lt;ASCENDING&gt; | &lt;DESCENDING&gt; ) [ &lt;KEY&gt; ] ( QualifiedDataName() [ &lt;COMMACHAR&gt; ] )+ )+
     * nodeOptional -&gt; [ [ &lt;COLLATING&gt; ] &lt;SEQUENCE&gt; [ &lt;IS&gt; ] AlphabetName() ]
     * nodeToken1 -&gt; &lt;USING&gt;
     * fileName1 -&gt; FileName()
     * nodeList1 -&gt; ( [ &lt;COMMACHAR&gt; ] FileName() )+
     * nodeChoice -&gt; ( &lt;OUTPUT&gt; &lt;PROCEDURE&gt; [ &lt;IS&gt; ] ProcedureName() [ ( &lt;THROUGH&gt; | &lt;THRU&gt; ) ProcedureName() ] | &lt;GIVING&gt; ( FileName() )+ )
     * </PRE>
     */
    public void visit(MergeStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.fileName.accept(this);
        processList(n.nodeList);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeToken1.accept(this);
        n.fileName1.accept(this);
        processList(n.nodeList1);
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;MOVE&gt;
     * nodeChoice -&gt; ( ( Identifier() | Literal() ) &lt;TO&gt; ( Identifier() [ &lt;COMMACHAR&gt; ] )+ | ( &lt;CORRESPONDING&gt; | &lt;CORR&gt; ) Identifier() &lt;TO&gt; ( Identifier() [ &lt;COMMACHAR&gt; ] )+ )
     * </PRE>
     */
    public void visit(MoveStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;MULTIPLY&gt;
     * multiplyBody -&gt; MultiplyBody()
     * nodeOptional -&gt; [ [ &lt;ON&gt; ] &lt;SIZE&gt; &lt;ERROR&gt; StatementList() ]
     * nodeOptional1 -&gt; [ &lt;NOT&gt; [ &lt;ON&gt; ] &lt;SIZE&gt; &lt;ERROR&gt; StatementList() ]
     * nodeOptional2 -&gt; [ &lt;END_MULTIPLY&gt; ]
     * </PRE>
     */
    public void visit(MultiplyStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.multiplyBody.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        if (n.nodeOptional2.present()) {
            n.nodeOptional2.accept(this);
        }
    }

    /**
     * <PRE>
     * idOrLiteral -&gt; IdOrLiteral()
     * nodeToken -&gt; &lt;BY&gt;
     * nodeChoice -&gt; ( IdOrLiteral() &lt;GIVING&gt; ArithIdentifierList() | ArithIdentifierList() )
     * </PRE>
     */
    public void visit(MultiplyBody n) throws Exception {
        n.idOrLiteral.accept(this);
        n.nodeToken.accept(this);
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;OPEN&gt;
     * nodeList -&gt; ( &lt;INPUT&gt; ( FileName() [ ( &lt;REVERSED&gt; | [ &lt;WITH&gt; ] &lt;NO&gt; &lt;REWIND&gt; ) ] [ &lt;COMMACHAR&gt; ] )+ | &lt;OUTPUT&gt; ( FileName() [ [ &lt;WITH&gt; ] &lt;NO&gt; &lt;REWIND&gt; ] [ &lt;COMMACHAR&gt; ] )+ | &lt;I_O&gt; ( FileName() [ &lt;COMMACHAR&gt; ] )+ | &lt;EXTEND&gt; ( FileName() [ &lt;COMMACHAR&gt; ] )+ )+
     * </PRE>
     */
    public void visit(OpenStatement n) throws Exception {
        n.nodeToken.accept(this);
        processList(n.nodeList);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;PERFORM&gt;
     * performBody -&gt; PerformBody()
     * </PRE>
     */
    public void visit(PerformStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.performBody.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; [ PerformOption() ] [ StatementList() ] &lt;END_PERFORM&gt;
     *       | PerformProcedure() [ PerformOption() ]
     * </PRE>
     */
    public void visit(PerformBody n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * procedureName -&gt; ProcedureName()
     * nodeOptional -&gt; [ ( &lt;THRU&gt; | &lt;THROUGH&gt; ) ProcedureName() ]
     * </PRE>
     */
    public void visit(PerformProcedure n) throws Exception {
        n.procedureName.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; &lt;BEFORE&gt;
     *       | &lt;AFTER&gt;
     * </PRE>
     */
    public void visit(BeforeOrAfter n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( Identifier() | Literal() ) &lt;TIMES&gt;
     *       | [ PerformTest() ] &lt;UNTIL&gt; Condition()
     *       | [ PerformTest() ] &lt;VARYING&gt; PerformVaryingList()
     * </PRE>
     */
    public void visit(PerformOption n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeOptional -&gt; [ &lt;WITH&gt; ]
     * nodeToken -&gt; &lt;TEST&gt;
     * beforeOrAfter -&gt; BeforeOrAfter()
     * </PRE>
     */
    public void visit(PerformTest n) throws Exception {
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeToken.accept(this);
        n.beforeOrAfter.accept(this);
    }

    /**
     * <PRE>
     * performVarying -&gt; PerformVarying()
     * nodeListOptional -&gt; ( &lt;AFTER&gt; PerformVarying() [ &lt;COMMACHAR&gt; ] )*
     * </PRE>
     */
    public void visit(PerformVaryingList n) throws Exception {
        n.performVarying.accept(this);
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
    }

    /**
     * <PRE>
     * identifier -&gt; Identifier()
     * nodeToken -&gt; &lt;FROM&gt;
     * idOrLiteral -&gt; IdOrLiteral()
     * nodeToken1 -&gt; &lt;BY&gt;
     * idOrLiteral1 -&gt; IdOrLiteral()
     * nodeToken2 -&gt; &lt;UNTIL&gt;
     * condition -&gt; Condition()
     * </PRE>
     */
    public void visit(PerformVarying n) throws Exception {
        n.identifier.accept(this);
        n.nodeToken.accept(this);
        n.idOrLiteral.accept(this);
        n.nodeToken1.accept(this);
        n.idOrLiteral1.accept(this);
        n.nodeToken2.accept(this);
        n.condition.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;READ&gt;
     * fileName -&gt; FileName()
     * nodeOptional -&gt; [ &lt;NEXT&gt; ]
     * nodeOptional1 -&gt; [ &lt;RECORD&gt; ]
     * nodeOptional2 -&gt; [ &lt;INTO&gt; Identifier() ]
     * nodeOptional3 -&gt; [ &lt;KEY&gt; [ &lt;IS&gt; ] QualifiedDataName() ]
     * nodeOptional4 -&gt; [ &lt;INVALID&gt; [ &lt;KEY&gt; ] StatementList() ]
     * nodeOptional5 -&gt; [ &lt;NOT&gt; &lt;INVALID&gt; [ &lt;KEY&gt; ] StatementList() ]
     * nodeOptional6 -&gt; [ [ &lt;AT&gt; ] &lt;END&gt; StatementList() ]
     * nodeOptional7 -&gt; [ &lt;NOT&gt; [ &lt;AT&gt; ] &lt;END&gt; StatementList() ]
     * nodeOptional8 -&gt; [ &lt;END_READ&gt; ]
     * </PRE>
     */
    public void visit(ReadStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.fileName.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        if (n.nodeOptional2.present()) {
            n.nodeOptional2.accept(this);
        }
        if (n.nodeOptional3.present()) {
            n.nodeOptional3.accept(this);
        }
        if (n.nodeOptional4.present()) {
            n.nodeOptional4.accept(this);
        }
        if (n.nodeOptional5.present()) {
            n.nodeOptional5.accept(this);
        }
        if (n.nodeOptional6.present()) {
            n.nodeOptional6.accept(this);
        }
        if (n.nodeOptional7.present()) {
            n.nodeOptional7.accept(this);
        }
        if (n.nodeOptional8.present()) {
            n.nodeOptional8.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;RELEASE&gt;
     * recordName -&gt; RecordName()
     * nodeOptional -&gt; [ &lt;FROM&gt; QualifiedDataName() ]
     * </PRE>
     */
    public void visit(ReleaseStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.recordName.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;RETURN&gt;
     * fileName -&gt; FileName()
     * nodeOptional -&gt; [ &lt;RECORD&gt; ]
     * nodeOptional1 -&gt; [ &lt;INTO&gt; QualifiedDataName() ]
     * nodeOptional2 -&gt; [ &lt;AT&gt; ]
     * nodeToken1 -&gt; &lt;END&gt;
     * statementList -&gt; StatementList()
     * nodeOptional3 -&gt; [ &lt;NOT&gt; [ &lt;AT&gt; ] &lt;END&gt; StatementList() ]
     * nodeOptional4 -&gt; [ &lt;END_RETURN&gt; ]
     * </PRE>
     */
    public void visit(ReturnStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.fileName.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        if (n.nodeOptional2.present()) {
            n.nodeOptional2.accept(this);
        }
        n.nodeToken1.accept(this);
        n.statementList.accept(this);
        if (n.nodeOptional3.present()) {
            n.nodeOptional3.accept(this);
        }
        if (n.nodeOptional4.present()) {
            n.nodeOptional4.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;REWRITE&gt;
     * recordName -&gt; RecordName()
     * nodeOptional -&gt; [ &lt;FROM&gt; Identifier() ]
     * nodeOptional1 -&gt; [ &lt;INVALID&gt; [ &lt;KEY&gt; ] StatementList() ]
     * nodeOptional2 -&gt; [ &lt;NOT&gt; &lt;INVALID&gt; [ &lt;KEY&gt; ] StatementList() ]
     * nodeOptional3 -&gt; [ &lt;END_REWRITE&gt; ]
     * </PRE>
     */
    public void visit(RewriteStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.recordName.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        if (n.nodeOptional2.present()) {
            n.nodeOptional2.accept(this);
        }
        if (n.nodeOptional3.present()) {
            n.nodeOptional3.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;SEARCH&gt;
     * nodeOptional -&gt; [ &lt;ALL&gt; ]
     * qualifiedDataName -&gt; QualifiedDataName()
     * nodeOptional1 -&gt; [ &lt;VARYING&gt; QualifiedDataName() ]
     * nodeOptional2 -&gt; [ [ &lt;AT&gt; ] &lt;END&gt; StatementList() ]
     * nodeList -&gt; ( &lt;WHEN&gt; Condition() ( StatementList() | &lt;NEXT&gt; &lt;SENTENCE&gt; ) )+
     * nodeOptional3 -&gt; [ &lt;END_SEARCH&gt; ]
     * </PRE>
     */
    public void visit(SearchStatement n) throws Exception {
        n.nodeToken.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.qualifiedDataName.accept(this);
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        if (n.nodeOptional2.present()) {
            n.nodeOptional2.accept(this);
        }
        processList(n.nodeList);
        if (n.nodeOptional3.present()) {
            n.nodeOptional3.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;SET&gt;
     * nodeList -&gt; ( ( Identifier() [ &lt;COMMACHAR&gt; ] )+ ( &lt;TO&gt; ( Identifier() | &lt;TRUE&gt; | &lt;FALSE&gt; | &lt;ON&gt; | &lt;OFF&gt; | Literal() ) | ( &lt;UP&gt; | &lt;DOWN&gt; ) [ &lt;BY&gt; ] ( Identifier() | Literal() ) ) )+
     * </PRE>
     */
    public void visit(SetStatement n) throws Exception {
        n.nodeToken.accept(this);
        processList(n.nodeList);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;SORT&gt;
     * fileName -&gt; FileName()
     * nodeList -&gt; ( [ &lt;ON&gt; ] ( &lt;ASCENDING&gt; | &lt;DESCENDING&gt; ) [ &lt;KEY&gt; ] ( QualifiedDataName() [ &lt;COMMACHAR&gt; ] )+ )+
     * nodeOptional -&gt; [ [ &lt;WITH&gt; ] &lt;DUPLICATES&gt; [ &lt;IN&gt; ] [ &lt;ORDER&gt; ] ]
     * nodeOptional1 -&gt; [ [ &lt;COLLATING&gt; ] &lt;SEQUENCE&gt; [ &lt;IS&gt; ] AlphabetName() ]
     * nodeChoice -&gt; ( &lt;USING&gt; ( FileName() )+ | &lt;INPUT&gt; &lt;PROCEDURE&gt; [ &lt;IS&gt; ] ProcedureName() [ ( &lt;THROUGH&gt; | &lt;THRU&gt; ) ProcedureName() ] )
     * nodeChoice1 -&gt; ( &lt;GIVING&gt; ( FileName() )+ | &lt;OUTPUT&gt; &lt;PROCEDURE&gt; [ &lt;IS&gt; ] ProcedureName() [ ( &lt;THROUGH&gt; | &lt;THRU&gt; ) ProcedureName() ] )
     * </PRE>
     */
    public void visit(SortStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.fileName.accept(this);
        processList(n.nodeList);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        n.nodeChoice.accept(this);
        n.nodeChoice1.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;START&gt;
     * fileName -&gt; FileName()
     * nodeOptional -&gt; [ &lt;KEY&gt; [ &lt;IS&gt; ] ( &lt;EQUAL&gt; [ &lt;TO&gt; ] | &lt;EQUALCHAR&gt; | &lt;GREATER&gt; [ &lt;THAN&gt; ] &lt;OR&gt; &lt;EQUAL&gt; [ &lt;TO&gt; ] | &lt;GREATER&gt; [ &lt;THAN&gt; ] | &lt;MORETHANCHAR&gt; | &lt;NOT&gt; &lt;LESS&gt; [ &lt;THAN&gt; ] | &lt;NOT&gt; &lt;LESSTHANCHAR&gt; | &lt;MORETHANOREQUAL&gt; ) QualifiedDataName() ]
     * nodeOptional1 -&gt; [ &lt;INVALID&gt; [ &lt;KEY&gt; ] StatementList() ]
     * nodeOptional2 -&gt; [ &lt;NOT&gt; &lt;INVALID&gt; [ &lt;KEY&gt; ] StatementList() ]
     * nodeOptional3 -&gt; [ &lt;END_START&gt; ]
     * </PRE>
     */
    public void visit(StartStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.fileName.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        if (n.nodeOptional2.present()) {
            n.nodeOptional2.accept(this);
        }
        if (n.nodeOptional3.present()) {
            n.nodeOptional3.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;STOP&gt;
     * nodeChoice -&gt; ( &lt;RUN&gt; | Literal() )
     * </PRE>
     */
    public void visit(StopStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;STRING&gt;
     * nodeList -&gt; ( ( Identifier() | Literal() )+ [ &lt;DELIMITED&gt; [ &lt;BY&gt; ] ( Identifier() | Literal() | &lt;SIZE&gt; ) ] )+
     * nodeToken1 -&gt; &lt;INTO&gt;
     * identifier -&gt; Identifier()
     * nodeOptional -&gt; [ [ &lt;WITH&gt; ] &lt;POINTER&gt; QualifiedDataName() ]
     * nodeOptional1 -&gt; [ [ &lt;ON&gt; ] &lt;OVERFLOW&gt; StatementList() ]
     * nodeOptional2 -&gt; [ &lt;NOT&gt; [ &lt;ON&gt; ] &lt;OVERFLOW&gt; StatementList() ]
     * nodeOptional3 -&gt; [ &lt;END_STRING&gt; ]
     * </PRE>
     */
    public void visit(StringStatement n) throws Exception {
        n.nodeToken.accept(this);
        processList(n.nodeList);
        n.nodeToken1.accept(this);
        n.identifier.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        if (n.nodeOptional2.present()) {
            n.nodeOptional2.accept(this);
        }
        if (n.nodeOptional3.present()) {
            n.nodeOptional3.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;SUBTRACT&gt;
     * nodeChoice -&gt; ( IdOrLiteralList() &lt;FROM&gt; ( IdOrLiteral() &lt;GIVING&gt; ArithIdentifierList() | ArithIdentifierList() ) | ( &lt;CORRESPONDING&gt; | &lt;CORR&gt; ) QualifiedDataName() &lt;FROM&gt; QualifiedDataName() )
     * nodeOptional -&gt; [ [ &lt;ON&gt; ] &lt;SIZE&gt; &lt;ERROR&gt; StatementList() ]
     * nodeOptional1 -&gt; [ &lt;NOT&gt; [ &lt;ON&gt; ] &lt;SIZE&gt; &lt;ERROR&gt; StatementList() ]
     * nodeOptional2 -&gt; [ &lt;END_SUBTRACT&gt; ]
     * </PRE>
     */
    public void visit(SubtractStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeChoice.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        if (n.nodeOptional2.present()) {
            n.nodeOptional2.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;UNSTRING&gt;
     * identifier -&gt; Identifier()
     * nodeOptional -&gt; [ &lt;DELIMITED&gt; [ &lt;BY&gt; ] [ &lt;ALL&gt; ] ( Identifier() | Literal() ) ( &lt;OR&gt; [ &lt;ALL&gt; ] ( Identifier() | Literal() ) )* ]
     * nodeToken1 -&gt; &lt;INTO&gt;
     * nodeList -&gt; ( Identifier() [ &lt;DELIMITER&gt; [ &lt;IN&gt; ] Identifier() ] [ &lt;COUNT&gt; [ &lt;IN&gt; ] Identifier() ] [ &lt;COMMACHAR&gt; ] )+
     * nodeOptional1 -&gt; [ [ &lt;WITH&gt; ] &lt;POINTER&gt; QualifiedDataName() ]
     * nodeOptional2 -&gt; [ &lt;TALLYING&gt; [ &lt;IN&gt; ] QualifiedDataName() ]
     * nodeOptional3 -&gt; [ [ &lt;ON&gt; ] &lt;OVERFLOW&gt; StatementList() ]
     * nodeOptional4 -&gt; [ &lt;NOT&gt; [ &lt;ON&gt; ] &lt;OVERFLOW&gt; StatementList() ]
     * nodeOptional5 -&gt; [ &lt;END_UNSTRING&gt; ]
     * </PRE>
     */
    public void visit(UnstringStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.identifier.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeToken1.accept(this);
        processList(n.nodeList);
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        if (n.nodeOptional2.present()) {
            n.nodeOptional2.accept(this);
        }
        if (n.nodeOptional3.present()) {
            n.nodeOptional3.accept(this);
        }
        if (n.nodeOptional4.present()) {
            n.nodeOptional4.accept(this);
        }
        if (n.nodeOptional5.present()) {
            n.nodeOptional5.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;USE&gt;
     * nodeChoice -&gt; ( [ &lt;FOR&gt; ] &lt;DEBUGGING&gt; [ &lt;ON&gt; ] ( ( Identifier() | &lt;ALL&gt; [ &lt;REFERENCES&gt; ] [ &lt;OF&gt; ] Identifier() | FileName() | ProcedureName() )+ | &lt;ALL&gt; &lt;PROCEDURES&gt; ) | [ &lt;GLOBAL&gt; ] &lt;AFTER&gt; [ &lt;STANDARD&gt; ] ( ( &lt;EXCEPTION&gt; | &lt;ERROR&gt; ) | [ ( &lt;BEGINNING&gt; | &lt;ENDING&gt; ) ] [ ( &lt;FILE&gt; | &lt;REEL&gt; | &lt;UNIT&gt; ) ] &lt;LABEL&gt; ) &lt;PROCEDURE&gt; [ &lt;ON&gt; ] ( ( FileName() [ &lt;COMMACHAR&gt; ] )+ | &lt;INPUT&gt; | &lt;OUTPUT&gt; | &lt;I_O&gt; | &lt;EXTEND&gt; ) )
     * </PRE>
     */
    public void visit(UseStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;WRITE&gt;
     * recordName -&gt; RecordName()
     * nodeOptional -&gt; [ &lt;FROM&gt; ( Identifier() | Literal() ) ]
     * nodeOptional1 -&gt; [ AdvancingPhrase() ]
     * nodeOptional2 -&gt; [ [ &lt;AT&gt; ] ( &lt;END_OF_PAGE&gt; | &lt;EOP&gt; ) StatementList() ]
     * nodeOptional3 -&gt; [ &lt;NOT&gt; [ &lt;AT&gt; ] ( &lt;END_OF_PAGE&gt; | &lt;EOP&gt; ) StatementList() ]
     * nodeOptional4 -&gt; [ &lt;INVALID&gt; [ &lt;KEY&gt; ] StatementList() ]
     * nodeOptional5 -&gt; [ &lt;NOT&gt; &lt;INVALID&gt; [ &lt;KEY&gt; ] StatementList() ]
     * nodeOptional6 -&gt; [ &lt;END_WRITE&gt; ]
     * </PRE>
     */
    public void visit(WriteStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.recordName.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        if (n.nodeOptional2.present()) {
            n.nodeOptional2.accept(this);
        }
        if (n.nodeOptional3.present()) {
            n.nodeOptional3.accept(this);
        }
        if (n.nodeOptional4.present()) {
            n.nodeOptional4.accept(this);
        }
        if (n.nodeOptional5.present()) {
            n.nodeOptional5.accept(this);
        }
        if (n.nodeOptional6.present()) {
            n.nodeOptional6.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( &lt;BEFORE&gt; | &lt;AFTER&gt; )
     * nodeOptional -&gt; [ &lt;ADVANCING&gt; ]
     * nodeChoice1 -&gt; ( &lt;PAGE&gt; | ( Identifier() | IntegerConstant() | FigurativeConstant() ) [ ( &lt;LINE&gt; | &lt;LINES&gt; ) ] | MnemonicName() )
     * </PRE>
     */
    public void visit(AdvancingPhrase n) throws Exception {
        n.nodeChoice.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeChoice1.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;S_IDENTIFIER&gt;
     * </PRE>
     */
    public void visit(S_Identifier n) throws Exception {
        n.nodeToken.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;S_QUOTED_IDENTIFIER&gt;
     * </PRE>
     */
    public void visit(S_Quoted_Identifier n) throws Exception {
        n.nodeToken.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;S_CHAR_LITERAL&gt;
     * </PRE>
     */
    public void visit(S_Char_Literal n) throws Exception {
        n.nodeToken.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; SQLCloseStatement()
     *       | CommitStatement()
     *       | [ SQLUsingDMLReturn() ] ( SQLDeleteStatement() | InsertStatement() | UpdateStatement() )
     *       | FetchStatement()
     *       | LockTableStatement()
     *       | SQLOpenStatement()
     *       | RollbackStatement()
     *       | SavepointStatement()
     *       | QueryStatement()
     *       | SQLSetStatement()
     * </PRE>
     */
    public void visit(SQLStatement n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;K_CLOSE&gt;
     * relObjectName -&gt; RelObjectName()
     * </PRE>
     */
    public void visit(SQLCloseStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.relObjectName.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;K_COMMIT&gt;
     * nodeOptional -&gt; [ &lt;K_WORK&gt; ]
     * nodeOptional1 -&gt; [ &lt;K_COMMENT&gt; S_Char_Literal() ]
     * </PRE>
     */
    public void visit(CommitStatement n) throws Exception {
        n.nodeToken.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeOptional -&gt; [ &lt;K_FOR&gt; ( RelObjectName() | &lt;S_BIND&gt; ) ]
     * nodeToken -&gt; &lt;K_FETCH&gt;
     * nodeSequence -&gt; ( RelObjectName() )
     * nodeToken1 -&gt; &lt;K_INTO&gt;
     * nodeChoice -&gt; ( RelObjectName() [ [ &lt;K_INDICATOR&gt; ] &lt;S_BIND&gt; ] | IndicatorBind() )
     * nodeListOptional -&gt; ( &lt;COMMACHAR&gt; ( RelObjectName() [ [ &lt;K_INDICATOR&gt; ] &lt;S_BIND&gt; ] | IndicatorBind() ) )*
     * </PRE>
     */
    public void visit(FetchStatement n) throws Exception {
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeToken.accept(this);
        n.nodeSequence.accept(this);
        n.nodeToken1.accept(this);
        n.nodeChoice.accept(this);
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;S_BIND&gt;
     * nodeOptional -&gt; [ [ &lt;K_INDICATOR&gt; ] &lt;S_BIND&gt; ]
     * </PRE>
     */
    public void visit(IndicatorBind n) throws Exception {
        n.nodeToken.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;K_LOCK&gt;
     * nodeToken1 -&gt; &lt;K_TABLE&gt;
     * tableReference -&gt; TableReference()
     * nodeListOptional -&gt; ( &lt;COMMACHAR&gt; TableReference() )*
     * nodeToken2 -&gt; &lt;K_IN&gt;
     * lockMode -&gt; LockMode()
     * nodeToken3 -&gt; &lt;K_MODE&gt;
     * nodeOptional -&gt; [ &lt;K_NOWAIT&gt; ]
     * </PRE>
     */
    public void visit(LockTableStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
        n.tableReference.accept(this);
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
        n.nodeToken2.accept(this);
        n.lockMode.accept(this);
        n.nodeToken3.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;K_OPEN&gt;
     * relObjectName -&gt; RelObjectName()
     * nodeOptional -&gt; [ &lt;K_USING&gt; Arguments() ]
     * </PRE>
     */
    public void visit(SQLOpenStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.relObjectName.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;K_ROLLBACK&gt;
     * nodeOptional -&gt; [ &lt;K_WORK&gt; ]
     * nodeOptional1 -&gt; [ &lt;K_TO&gt; [ &lt;K_SAVEPOINT&gt; ] RelObjectName() ]
     * nodeOptional2 -&gt; [ &lt;K_COMMENT&gt; S_Char_Literal() ]
     * </PRE>
     */
    public void visit(RollbackStatement n) throws Exception {
        n.nodeToken.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        if (n.nodeOptional2.present()) {
            n.nodeOptional2.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;K_SET&gt;
     * nodeToken1 -&gt; &lt;K_TRANSACTION&gt;
     * nodeChoice -&gt; ( ( &lt;K_READ&gt; ( &lt;K_ONLY&gt; | &lt;K_WRITE&gt; ) ) | ( &lt;K_USE&gt; &lt;K_ROLLBACK&gt; &lt;K_SEGMENT&gt; RelObjectName() ) )
     * </PRE>
     */
    public void visit(SetTransactionStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;K_SET&gt;
     * relObjectName -&gt; RelObjectName()
     * nodeChoice -&gt; ( &lt;K_TO&gt; | &quot;=&quot; )
     * arguments -&gt; Arguments()
     * </PRE>
     */
    public void visit(SetVariableStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.relObjectName.accept(this);
        n.nodeChoice.accept(this);
        n.arguments.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; SetTransactionStatement()
     *       | SetVariableStatement()
     * </PRE>
     */
    public void visit(SQLSetStatement n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( &lt;K_ROW&gt; ( &lt;K_SHARE&gt; | &lt;K_EXCLUSIVE&gt; ) )
     *       | ( &lt;K_SHARE&gt; [ &lt;K_UPDATE&gt; | ( &lt;K_ROW&gt; &lt;K_EXCLUSIVE&gt; ) ] )
     *       | ( &lt;K_EXCLUSIVE&gt; )
     * </PRE>
     */
    public void visit(LockMode n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;K_SAVEPOINT&gt;
     * relObjectName -&gt; RelObjectName()
     * </PRE>
     */
    public void visit(SavepointStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.relObjectName.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;K_UPDATE&gt;
     * tableReference -&gt; TableReference()
     * nodeOptional -&gt; [ RelObjectName() ]
     * nodeToken1 -&gt; &lt;K_SET&gt;
     * columnValues -&gt; ColumnValues()
     * nodeOptional1 -&gt; [ &lt;K_WHERE&gt; ( SQLExpression() | &lt;K_CURRENT&gt; &lt;K_OF&gt; RelObjectName() ) ]
     * </PRE>
     */
    public void visit(UpdateStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.tableReference.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeToken1.accept(this);
        n.columnValues.accept(this);
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
    }

    /**
     * <PRE>
     * tableColumn -&gt; TableColumn()
     * nodeToken -&gt; &quot;=&quot;
     * updatedValue -&gt; UpdatedValue()
     * nodeListOptional -&gt; ( &lt;COMMACHAR&gt; TableColumn() &quot;=&quot; UpdatedValue() )*
     * </PRE>
     */
    public void visit(ColumnValues n) throws Exception {
        n.tableColumn.accept(this);
        n.nodeToken.accept(this);
        n.updatedValue.accept(this);
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; &lt;LPARENCHAR&gt; SelectStatement() &lt;RPARENCHAR&gt;
     *       | PlSqlExpression()
     * </PRE>
     */
    public void visit(UpdatedValue n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;K_INSERT&gt;
     * nodeToken1 -&gt; &lt;K_INTO&gt;
     * tableReference -&gt; TableReference()
     * nodeOptional -&gt; [ &lt;LPARENCHAR&gt; TableColumn() ( &lt;COMMACHAR&gt; TableColumn() )* &lt;RPARENCHAR&gt; ]
     * nodeChoice -&gt; ( &lt;K_VALUES&gt; &lt;LPARENCHAR&gt; PlSqlExpressionList() &lt;RPARENCHAR&gt; | SelectStatement() )
     * </PRE>
     */
    public void visit(InsertStatement n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
        n.tableReference.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;K_USING&gt;
     * nodeChoice -&gt; ( &lt;S_IDENTIFIER&gt; | &lt;S_BIND&gt; )
     * </PRE>
     */
    public void visit(SQLUsingDMLReturn n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;K_DELETE&gt;
     * nodeOptional -&gt; [ &lt;K_FROM&gt; ]
     * tableReference -&gt; TableReference()
     * nodeOptional1 -&gt; [ RelObjectName() ]
     * nodeOptional2 -&gt; [ &lt;K_WHERE&gt; ( SQLExpression() | &lt;K_CURRENT&gt; &lt;K_OF&gt; RelObjectName() ) ]
     * </PRE>
     */
    public void visit(SQLDeleteStatement n) throws Exception {
        n.nodeToken.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.tableReference.accept(this);
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        if (n.nodeOptional2.present()) {
            n.nodeOptional2.accept(this);
        }
    }

    /**
     * <PRE>
     * selectStatement -&gt; SelectStatement()
     * </PRE>
     */
    public void visit(QueryStatement n) throws Exception {
        n.selectStatement.accept(this);
    }

    /**
     * <PRE>
     * plSqlExpressions -&gt; PlSqlExpressions()
     * </PRE>
     */
    public void visit(PlSqlExpression n) throws Exception {
        n.plSqlExpressions.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; PlSqlOrExpression()
     *       | PlSqlAndExpressions()
     * </PRE>
     */
    public void visit(PlSqlExpressions n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * plSqlAndExpressions -&gt; PlSqlAndExpressions()
     * nodeList -&gt; ( &lt;K_OR&gt; PlSqlAndExpressions() )+
     * </PRE>
     */
    public void visit(PlSqlOrExpression n) throws Exception {
        n.plSqlAndExpressions.accept(this);
        processList(n.nodeList);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; PlSqlAndExpression()
     *       | PlSqlUnaryLogicalExpressions()
     * </PRE>
     */
    public void visit(PlSqlAndExpressions n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * plSqlUnaryLogicalExpressions -&gt; PlSqlUnaryLogicalExpressions()
     * nodeList -&gt; ( &lt;K_AND&gt; PlSqlUnaryLogicalExpressions() )+
     * </PRE>
     */
    public void visit(PlSqlAndExpression n) throws Exception {
        n.plSqlUnaryLogicalExpressions.accept(this);
        processList(n.nodeList);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; PlSqlUnaryLogicalExpression()
     *       | PlSqlRelationalExpressions()
     * </PRE>
     */
    public void visit(PlSqlUnaryLogicalExpressions n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;K_NOT&gt;
     * plSqlRelationalExpressions -&gt; PlSqlRelationalExpressions()
     * </PRE>
     */
    public void visit(PlSqlUnaryLogicalExpression n) throws Exception {
        n.nodeToken.accept(this);
        n.plSqlRelationalExpressions.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; PlSqlRelationalExpression()
     *       | PlSqlSimpleExpressions()
     * </PRE>
     */
    public void visit(PlSqlRelationalExpressions n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * plSqlSimpleExpressions -&gt; PlSqlSimpleExpressions()
     * nodeChoice -&gt; ( Relop() PlSqlSimpleExpressions() | PlSqlInClause() | PlSqlBetweenClause() | PlSqlLikeClause() | IsNullClause() )
     * </PRE>
     */
    public void visit(PlSqlRelationalExpression n) throws Exception {
        n.plSqlSimpleExpressions.accept(this);
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * plSqlExpression -&gt; PlSqlExpression()
     * nodeListOptional -&gt; ( &lt;COMMACHAR&gt; PlSqlExpression() )*
     * </PRE>
     */
    public void visit(PlSqlExpressionList n) throws Exception {
        n.plSqlExpression.accept(this);
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
    }

    /**
     * <PRE>
     * nodeOptional -&gt; [ &lt;K_NOT&gt; ]
     * nodeToken -&gt; &lt;K_IN&gt;
     * nodeToken1 -&gt; &lt;LPARENCHAR&gt;
     * plSqlExpressionList -&gt; PlSqlExpressionList()
     * nodeToken2 -&gt; &lt;RPARENCHAR&gt;
     * </PRE>
     */
    public void visit(PlSqlInClause n) throws Exception {
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
        n.plSqlExpressionList.accept(this);
        n.nodeToken2.accept(this);
    }

    /**
     * <PRE>
     * nodeOptional -&gt; [ &lt;K_NOT&gt; ]
     * nodeToken -&gt; &lt;K_BETWEEN&gt;
     * plSqlSimpleExpressions -&gt; PlSqlSimpleExpressions()
     * nodeToken1 -&gt; &lt;K_AND&gt;
     * plSqlSimpleExpressions1 -&gt; PlSqlSimpleExpressions()
     * </PRE>
     */
    public void visit(PlSqlBetweenClause n) throws Exception {
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeToken.accept(this);
        n.plSqlSimpleExpressions.accept(this);
        n.nodeToken1.accept(this);
        n.plSqlSimpleExpressions1.accept(this);
    }

    /**
     * <PRE>
     * nodeOptional -&gt; [ &lt;K_NOT&gt; ]
     * nodeToken -&gt; &lt;K_LIKE&gt;
     * plSqlSimpleExpressions -&gt; PlSqlSimpleExpressions()
     * </PRE>
     */
    public void visit(PlSqlLikeClause n) throws Exception {
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeToken.accept(this);
        n.plSqlSimpleExpressions.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;K_IS&gt;
     * nodeOptional -&gt; [ &lt;K_NOT&gt; ]
     * nodeToken1 -&gt; &lt;K_NULL&gt;
     * </PRE>
     */
    public void visit(IsNullClause n) throws Exception {
        n.nodeToken.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeToken1.accept(this);
    }

    /**
     * <PRE>
     * plSqlSimpleExpressions -&gt; PlSqlSimpleExpressions()
     * </PRE>
     */
    public void visit(PlSqlSimpleExpression n) throws Exception {
        n.plSqlSimpleExpressions.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; PlSqlAdditiveExpression()
     *       | PlSqlMultiplicativeExpressions()
     * </PRE>
     */
    public void visit(PlSqlSimpleExpressions n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * plSqlMultiplicativeExpressions -&gt; PlSqlMultiplicativeExpressions()
     * nodeList -&gt; ( ( ( &lt;PLUSCHAR&gt; | &lt;PLUSCHAR_SUBS&gt; ) | ( &lt;MINUSCHAR&gt; | &lt;MINUSCHAR_SUBS&gt; ) | &quot;||&quot; ) PlSqlMultiplicativeExpressions() )+
     * </PRE>
     */
    public void visit(PlSqlAdditiveExpression n) throws Exception {
        n.plSqlMultiplicativeExpressions.accept(this);
        processList(n.nodeList);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; PlSqlMultiplicativeExpression()
     *       | PlSqlExpotentExpressions()
     * </PRE>
     */
    public void visit(PlSqlMultiplicativeExpressions n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * plSqlExpotentExpressions -&gt; PlSqlExpotentExpressions()
     * nodeList -&gt; ( ( &quot;*&quot; | &quot;/&quot; ) PlSqlExpotentExpressions() )+
     * </PRE>
     */
    public void visit(PlSqlMultiplicativeExpression n) throws Exception {
        n.plSqlExpotentExpressions.accept(this);
        processList(n.nodeList);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; PlSqlExpotentExpression()
     *       | PlSqlUnaryExpressions()
     * </PRE>
     */
    public void visit(PlSqlExpotentExpressions n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * plSqlUnaryExpressions -&gt; PlSqlUnaryExpressions()
     * nodeList -&gt; ( &lt;POW&gt; PlSqlUnaryExpressions() )+
     * </PRE>
     */
    public void visit(PlSqlExpotentExpression n) throws Exception {
        n.plSqlUnaryExpressions.accept(this);
        processList(n.nodeList);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; PlSqlUnaryExpression()
     *       | PlSqlPrimaryExpression()
     * </PRE>
     */
    public void visit(PlSqlUnaryExpressions n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeSequence -&gt; ( ( ( &lt;PLUSCHAR&gt; | &lt;PLUSCHAR_SUBS&gt; ) | ( &lt;MINUSCHAR&gt; | &lt;MINUSCHAR_SUBS&gt; ) ) PlSqlPrimaryExpression() )
     * </PRE>
     */
    public void visit(PlSqlUnaryExpression n) throws Exception {
        n.nodeSequence.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; &lt;K_NULL&gt;
     *       | ( RelObjectName() ( &quot;%FOUND&quot; | &quot;%NOTFOUND&quot; | &quot;%ISOPEN&quot; | &quot;%ROWCOUNT&quot; ) )
     *       | ( RelObjectName() &lt;LPARENCHAR&gt; Arguments() &lt;RPARENCHAR&gt; )
     *       | ( RelObjectName() [ &lt;DOTCHAR&gt; DotObjectName() ] )
     *       | ( &lt;K_SQL&gt; ( &quot;%FOUND&quot; | &quot;%NOTFOUND&quot; | &quot;%ISOPEN&quot; | &quot;%ROWCOUNT&quot; ) )
     *       | &lt;S_NUMBER&gt;
     *       | IndicatorBind()
     *       | &lt;LPARENCHAR&gt; PlSqlExpression() &lt;RPARENCHAR&gt;
     * </PRE>
     */
    public void visit(PlSqlPrimaryExpression n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * relObjectName -&gt; RelObjectName()
     * nodeOptional -&gt; [ &lt;DOTCHAR&gt; DotObjectName() [ &lt;DOTCHAR&gt; DotObjectName() ] ]
     * </PRE>
     */
    public void visit(TableColumn n) throws Exception {
        n.relObjectName.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; &lt;S_IDENTIFIER&gt;
     *       | &lt;S_QUOTED_IDENTIFIER&gt;
     *       | &lt;S_CHAR_LITERAL&gt;
     * </PRE>
     */
    public void visit(RelObjectName n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; &lt;S_IDENTIFIER&gt;
     *       | &lt;S_QUOTED_IDENTIFIER&gt;
     *       | &lt;S_CHAR_LITERAL&gt;
     * </PRE>
     */
    public void visit(DotObjectName n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; &lt;S_IDENTIFIER&gt;
     *       | &lt;S_QUOTED_IDENTIFIER&gt;
     * </PRE>
     */
    public void visit(OracleObjectName n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; &quot;=&quot;
     *       | &quot;!=&quot;
     *       | &quot;#&quot;
     *       | &quot;&lt;&gt;&quot;
     *       | &lt;MORETHANCHAR&gt;
     *       | &lt;MORETHANOREQUAL&gt;
     *       | &lt;LESSTHANCHAR&gt;
     *       | &lt;LESSTHANOREQUAL&gt;
     * </PRE>
     */
    public void visit(Relop n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * relObjectName -&gt; RelObjectName()
     * nodeOptional -&gt; [ &quot;/&quot; DotObjectName() ]
     * </PRE>
     */
    public void visit(TableReference n) throws Exception {
        n.relObjectName.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; &lt;S_IDENTIFIER&gt;
     *       | ( [ ( ( &lt;PLUSCHAR&gt; | &lt;PLUSCHAR_SUBS&gt; ) | ( &lt;MINUSCHAR&gt; | &lt;MINUSCHAR_SUBS&gt; ) ) ] &lt;S_NUMBER&gt; )
     * </PRE>
     */
    public void visit(NumOrID n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * plSqlExpressionList -&gt; PlSqlExpressionList()
     * </PRE>
     */
    public void visit(Arguments n) throws Exception {
        n.plSqlExpressionList.accept(this);
    }

    /**
     * <PRE>
     * selectWithoutOrder -&gt; SelectWithoutOrder()
     * nodeOptional -&gt; [ OrderByClause() ]
     * nodeOptional1 -&gt; [ ForUpdateClause() ]
     * </PRE>
     */
    public void visit(SelectStatement n) throws Exception {
        n.selectWithoutOrder.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;K_SELECT&gt;
     * nodeOptional -&gt; [ &lt;K_ALL&gt; | &lt;K_DISTINCT&gt; ]
     * selectList -&gt; SelectList()
     * nodeOptional1 -&gt; [ IntoClause() ]
     * fromClause -&gt; FromClause()
     * nodeOptional2 -&gt; [ WhereClause() ]
     * nodeOptional3 -&gt; [ ConnectClause() ]
     * nodeOptional4 -&gt; [ GroupByClause() ]
     * nodeOptional5 -&gt; [ SetClause() ]
     * </PRE>
     */
    public void visit(SelectWithoutOrder n) throws Exception {
        n.nodeToken.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.selectList.accept(this);
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        n.fromClause.accept(this);
        if (n.nodeOptional2.present()) {
            n.nodeOptional2.accept(this);
        }
        if (n.nodeOptional3.present()) {
            n.nodeOptional3.accept(this);
        }
        if (n.nodeOptional4.present()) {
            n.nodeOptional4.accept(this);
        }
        if (n.nodeOptional5.present()) {
            n.nodeOptional5.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; &lt;ASTERISKCHAR&gt;
     *       | SelectItem() ( &lt;COMMACHAR&gt; SelectItem() )*
     * </PRE>
     */
    public void visit(SelectList n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; SelectAllItems()
     *       | SQLSimpleExpression() [ &lt;S_IDENTIFIER&gt; ]
     *       | FunctionCall() [ AsObjectName() ]
     *       | SelectAllItems()
     *       | TableColumn() [ AsObjectName() ]
     * </PRE>
     */
    public void visit(SelectItem n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; RelObjectName() &lt;DOTCHAR&gt; &lt;ASTERISKCHAR&gt;
     *       | RelObjectName() &lt;DOTCHAR&gt; DotObjectName() &lt;DOTCHAR&gt; &lt;ASTERISKCHAR&gt;
     * </PRE>
     */
    public void visit(SelectAllItems n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; RelObjectName()
     *       | &lt;K_AS&gt; DotObjectName()
     * </PRE>
     */
    public void visit(AsObjectName n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;K_INTO&gt;
     * intoItem -&gt; IntoItem()
     * nodeListOptional -&gt; ( &lt;COMMACHAR&gt; IntoItem() )*
     * </PRE>
     */
    public void visit(IntoClause n) throws Exception {
        n.nodeToken.accept(this);
        n.intoItem.accept(this);
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( RelObjectName() [ &lt;DOTCHAR&gt; DotObjectName() ] )
     *       | ( IndicatorBind() )
     * </PRE>
     */
    public void visit(IntoItem n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;K_FROM&gt;
     * fromItem -&gt; FromItem()
     * nodeListOptional -&gt; ( &lt;COMMACHAR&gt; FromItem() )*
     * </PRE>
     */
    public void visit(FromClause n) throws Exception {
        n.nodeToken.accept(this);
        n.fromItem.accept(this);
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( TableReference() | &lt;LPARENCHAR&gt; FromItemExpression() &lt;RPARENCHAR&gt; )
     * nodeChoice1 -&gt; ( JoinerExpression() [ &lt;K_AS&gt; AsObjectName() ] | [ AsObjectName() ] )
     * </PRE>
     */
    public void visit(FromItem n) throws Exception {
        n.nodeChoice.accept(this);
        n.nodeChoice1.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( TableReference() | &lt;LPARENCHAR&gt; FromItemExpression() &lt;RPARENCHAR&gt; ) ( JoinerExpression() )*
     *       | SelectStatement()
     * </PRE>
     */
    public void visit(FromItemExpression n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; &lt;K_JOIN&gt; TableReference() [ JoinWhereClause() ]
     *       | RelObjectName() &lt;K_JOIN&gt; TableReference() [ JoinWhereClause() ]
     * </PRE>
     */
    public void visit(JoinerExpression n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;K_ON&gt;
     * sQLExpression -&gt; SQLExpression()
     * </PRE>
     */
    public void visit(JoinWhereClause n) throws Exception {
        n.nodeToken.accept(this);
        n.sQLExpression.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;K_WHERE&gt;
     * sQLExpression -&gt; SQLExpression()
     * </PRE>
     */
    public void visit(WhereClause n) throws Exception {
        n.nodeToken.accept(this);
        n.sQLExpression.accept(this);
    }

    /**
     * <PRE>
     * nodeSequence -&gt; ( [ &lt;K_START&gt; &lt;K_WITH&gt; SQLExpression() ] &lt;K_CONNECT&gt; &lt;K_BY&gt; SQLExpression() [ &lt;K_START&gt; &lt;K_WITH&gt; SQLExpression() ] )
     * </PRE>
     */
    public void visit(ConnectClause n) throws Exception {
        n.nodeSequence.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;K_GROUP&gt;
     * nodeToken1 -&gt; &lt;K_BY&gt;
     * sQLExpressionList -&gt; SQLExpressionList()
     * nodeOptional -&gt; [ &lt;K_HAVING&gt; SQLExpression() ]
     * </PRE>
     */
    public void visit(GroupByClause n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
        n.sQLExpressionList.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( ( &lt;K_UNION&gt; [ &lt;K_ALL&gt; ] ) | &lt;K_INTERSECT&gt; | &lt;K_MINUS&gt; )
     * nodeChoice1 -&gt; ( ( &lt;LPARENCHAR&gt; SelectStatement() &lt;RPARENCHAR&gt; ) | SelectStatement() )
     * </PRE>
     */
    public void visit(SetClause n) throws Exception {
        n.nodeChoice.accept(this);
        n.nodeChoice1.accept(this);
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;K_ORDER&gt;
     * nodeToken1 -&gt; &lt;K_BY&gt;
     * sQLSimpleExpression -&gt; SQLSimpleExpression()
     * nodeOptional -&gt; [ &lt;K_ASC&gt; | &lt;K_DESC&gt; ]
     * nodeListOptional -&gt; ( &lt;COMMACHAR&gt; SQLSimpleExpression() [ &lt;K_ASC&gt; | &lt;K_DESC&gt; ] )*
     * </PRE>
     */
    public void visit(OrderByClause n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
        n.sQLSimpleExpression.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
    }

    /**
     * <PRE>
     * nodeToken -&gt; &lt;K_FOR&gt;
     * nodeToken1 -&gt; &lt;K_UPDATE&gt;
     * nodeOptional -&gt; [ &lt;K_OF&gt; TableColumn() ( &lt;COMMACHAR&gt; TableColumn() )* ]
     * </PRE>
     */
    public void visit(ForUpdateClause n) throws Exception {
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
    }

    /**
     * <PRE>
     * sQLOrExpressions -&gt; SQLOrExpressions()
     * </PRE>
     */
    public void visit(SQLExpression n) throws Exception {
        n.sQLOrExpressions.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; SQLOrExpression()
     *       | SQLAndExpressions()
     * </PRE>
     */
    public void visit(SQLOrExpressions n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * sQLAndExpressions -&gt; SQLAndExpressions()
     * nodeList -&gt; ( &lt;K_OR&gt; SQLAndExpressions() )+
     * </PRE>
     */
    public void visit(SQLOrExpression n) throws Exception {
        n.sQLAndExpressions.accept(this);
        processList(n.nodeList);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; SQLAndExpression()
     *       | SQLUnaryLogicalExpressions()
     * </PRE>
     */
    public void visit(SQLAndExpressions n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * sQLUnaryLogicalExpressions -&gt; SQLUnaryLogicalExpressions()
     * nodeList -&gt; ( &lt;K_AND&gt; SQLUnaryLogicalExpressions() )+
     * </PRE>
     */
    public void visit(SQLAndExpression n) throws Exception {
        n.sQLUnaryLogicalExpressions.accept(this);
        processList(n.nodeList);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ExistsClause()
     *       | SQLRelationalExpressions()
     * </PRE>
     */
    public void visit(SQLUnaryLogicalExpressions n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeOptional -&gt; [ &lt;K_NOT&gt; ]
     * nodeToken -&gt; &lt;K_EXISTS&gt;
     * nodeToken1 -&gt; &lt;LPARENCHAR&gt;
     * subQuery -&gt; SubQuery()
     * nodeToken2 -&gt; &lt;RPARENCHAR&gt;
     * </PRE>
     */
    public void visit(ExistsClause n) throws Exception {
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
        n.subQuery.accept(this);
        n.nodeToken2.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; SQLRelationalExpression()
     *       | ( SQLRelopExpression() | &lt;LPARENCHAR&gt; SQLExpressionList() &lt;RPARENCHAR&gt; | ( SQLPriorExpression() | SQLSimpleExpressions() ) )
     * </PRE>
     */
    public void visit(SQLRelationalExpressions n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( &lt;LPARENCHAR&gt; SQLExpressionList() &lt;RPARENCHAR&gt; | ( SQLPriorExpression() | SQLSimpleExpressions() ) )
     * nodeChoice1 -&gt; ( ( SQLInClause() ) | ( SQLBetweenClause() ) | ( SQLLikeClause() ) | IsNullClause() )
     * </PRE>
     */
    public void visit(SQLRelationalExpression n) throws Exception {
        n.nodeChoice.accept(this);
        n.nodeChoice1.accept(this);
    }

    /**
     * <PRE>
     * nodeOptional -&gt; [ &lt;K_NOT&gt; ]
     * nodeToken -&gt; &lt;K_PRIOR&gt;
     * sQLSimpleExpressions -&gt; SQLSimpleExpressions()
     * </PRE>
     */
    public void visit(SQLPriorExpression n) throws Exception {
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeToken.accept(this);
        n.sQLSimpleExpressions.accept(this);
    }

    /**
     * <PRE>
     * sQLSimpleExpression -&gt; SQLSimpleExpression()
     * nodeListOptional -&gt; ( &lt;COMMACHAR&gt; SQLSimpleExpression() )*
     * </PRE>
     */
    public void visit(SQLExpressionList n) throws Exception {
        n.sQLSimpleExpression.accept(this);
        if (n.nodeListOptional.present()) {
            processList(n.nodeListOptional);
        }
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( &lt;LPARENCHAR&gt; SQLExpressionList() &lt;RPARENCHAR&gt; | ( SQLPriorExpression() | SQLSimpleExpressions() ) )
     * relop -&gt; Relop()
     * nodeChoice1 -&gt; ( ( [ &lt;K_ALL&gt; | &lt;K_ANY&gt; ] &lt;LPARENCHAR&gt; SubQuery() &lt;RPARENCHAR&gt; ) | SQLPriorExpression() | SQLSimpleExpressions() )
     * </PRE>
     */
    public void visit(SQLRelopExpression n) throws Exception {
        n.nodeChoice.accept(this);
        n.relop.accept(this);
        n.nodeChoice1.accept(this);
    }

    /**
     * <PRE>
     * relop -&gt; Relop()
     * nodeChoice -&gt; ( ( [ &lt;K_ALL&gt; | &lt;K_ANY&gt; ] &lt;LPARENCHAR&gt; SubQuery() &lt;RPARENCHAR&gt; ) | SQLPriorExpression() | SQLSimpleExpression() )
     * </PRE>
     */
    public void visit(SQLRelationalOperatorExpression n) throws Exception {
        n.relop.accept(this);
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeOptional -&gt; [ &lt;K_NOT&gt; ]
     * nodeToken -&gt; &lt;K_IN&gt;
     * nodeToken1 -&gt; &lt;LPARENCHAR&gt;
     * nodeChoice -&gt; ( SQLExpressionList() | SubQuery() )
     * nodeToken2 -&gt; &lt;RPARENCHAR&gt;
     * </PRE>
     */
    public void visit(SQLInClause n) throws Exception {
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeToken.accept(this);
        n.nodeToken1.accept(this);
        n.nodeChoice.accept(this);
        n.nodeToken2.accept(this);
    }

    /**
     * <PRE>
     * nodeOptional -&gt; [ &lt;K_NOT&gt; ]
     * nodeToken -&gt; &lt;K_BETWEEN&gt;
     * sQLSimpleExpression -&gt; SQLSimpleExpression()
     * nodeToken1 -&gt; &lt;K_AND&gt;
     * sQLSimpleExpression1 -&gt; SQLSimpleExpression()
     * </PRE>
     */
    public void visit(SQLBetweenClause n) throws Exception {
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeToken.accept(this);
        n.sQLSimpleExpression.accept(this);
        n.nodeToken1.accept(this);
        n.sQLSimpleExpression1.accept(this);
    }

    /**
     * <PRE>
     * nodeOptional -&gt; [ &lt;K_NOT&gt; ]
     * nodeToken -&gt; &lt;K_LIKE&gt;
     * sQLSimpleExpression -&gt; SQLSimpleExpression()
     * </PRE>
     */
    public void visit(SQLLikeClause n) throws Exception {
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeToken.accept(this);
        n.sQLSimpleExpression.accept(this);
    }

    /**
     * <PRE>
     * sQLSimpleExpressions -&gt; SQLSimpleExpressions()
     * </PRE>
     */
    public void visit(SQLSimpleExpression n) throws Exception {
        n.sQLSimpleExpressions.accept(this);
    }

    /**
     * <PRE>
     * sQLAdditiveExpressions -&gt; SQLAdditiveExpressions()
     * </PRE>
     */
    public void visit(SQLSimpleExpressions n) throws Exception {
        n.sQLAdditiveExpressions.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; SQLAdditiveExpression()
     *       | SQLMultiplicativeExpressions()
     * </PRE>
     */
    public void visit(SQLAdditiveExpressions n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * sQLMultiplicativeExpressions -&gt; SQLMultiplicativeExpressions()
     * nodeList -&gt; ( ( ( &lt;PLUSCHAR_SUBS&gt; | &lt;PLUSCHAR&gt; ) | ( &lt;MINUSCHAR_SUBS&gt; | &lt;MINUSCHAR&gt; ) | &lt;CONCAT&gt; ) SQLMultiplicativeExpressions() )+
     * </PRE>
     */
    public void visit(SQLAdditiveExpression n) throws Exception {
        n.sQLMultiplicativeExpressions.accept(this);
        processList(n.nodeList);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; SQLMultiplicativeExpression()
     *       | SQLExpotentExpressions()
     * </PRE>
     */
    public void visit(SQLMultiplicativeExpressions n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * sQLExpotentExpressions -&gt; SQLExpotentExpressions()
     * nodeList -&gt; ( ( &lt;ASTERISKCHAR&gt; | &lt;SLASHCHAR&gt; ) SQLExpotentExpressions() )+
     * </PRE>
     */
    public void visit(SQLMultiplicativeExpression n) throws Exception {
        n.sQLExpotentExpressions.accept(this);
        processList(n.nodeList);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; SQLExpotentExpression()
     *       | SQLUnaryExpressions()
     * </PRE>
     */
    public void visit(SQLExpotentExpressions n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * sQLUnaryExpressions -&gt; SQLUnaryExpressions()
     * nodeList -&gt; ( &lt;POW&gt; SQLUnaryExpressions() )+
     * </PRE>
     */
    public void visit(SQLExpotentExpression n) throws Exception {
        n.sQLUnaryExpressions.accept(this);
        processList(n.nodeList);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; SQLUnaryExpression()
     *       | SQLPrimaryExpression()
     * </PRE>
     */
    public void visit(SQLUnaryExpressions n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; ( ( &lt;PLUSCHAR&gt; | &lt;PLUSCHAR_SUBS&gt; ) | ( &lt;MINUSCHAR&gt; | &lt;MINUSCHAR_SUBS&gt; ) )
     * sQLPrimaryExpression -&gt; SQLPrimaryExpression()
     * </PRE>
     */
    public void visit(SQLUnaryExpression n) throws Exception {
        n.nodeChoice.accept(this);
        n.sQLPrimaryExpression.accept(this);
    }

    /**
     * <PRE>
     * nodeChoice -&gt; &lt;K_NULL&gt;
     *       | FunctionCall()
     *       | OuterJoinExpression()
     *       | TableColumn()
     *       | &lt;S_NUMBER&gt;
     *       | IndicatorBind()
     *       | &lt;LPARENCHAR&gt; SQLExpression() &lt;RPARENCHAR&gt;
     * </PRE>
     */
    public void visit(SQLPrimaryExpression n) throws Exception {
        n.nodeChoice.accept(this);
    }

    /**
     * <PRE>
     * relObjectName -&gt; RelObjectName()
     * nodeOptional -&gt; [ &lt;DOTCHAR&gt; DotObjectName() [ &lt;DOTCHAR&gt; DotObjectName() ] ]
     * nodeToken -&gt; &lt;LPARENCHAR&gt;
     * nodeOptional1 -&gt; [ [ &lt;K_DISTINCT&gt; | &lt;K_ALL&gt; ] ( SQLArguments() | &lt;ASTERISKCHAR&gt; ) ]
     * nodeToken1 -&gt; &lt;RPARENCHAR&gt;
     * </PRE>
     */
    public void visit(FunctionCall n) throws Exception {
        n.relObjectName.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeToken.accept(this);
        if (n.nodeOptional1.present()) {
            n.nodeOptional1.accept(this);
        }
        n.nodeToken1.accept(this);
    }

    /**
     * <PRE>
     * sQLExpressionList -&gt; SQLExpressionList()
     * </PRE>
     */
    public void visit(SQLArguments n) throws Exception {
        n.sQLExpressionList.accept(this);
    }

    /**
     * <PRE>
     * relObjectName -> RelObjectName()
     * nodeOptional -> [ &lt;DOTCHAR&gt; DotObjectName() [ &lt;DOTCHAR&gt; DotObjectName() ] ]
     * nodeToken -> &lt;LPARENCHAR&gt;
     * nodeChoice -> ( &lt;PLUSCHAR&gt; | &lt;PLUSCHAR_SUBS&gt; )
     * nodeToken1 -> &lt;RPARENCHAR&gt;
     * </PRE>
     */
    public void visit(OuterJoinExpression n) throws Exception {
        n.relObjectName.accept(this);
        if (n.nodeOptional.present()) {
            n.nodeOptional.accept(this);
        }
        n.nodeToken.accept(this);
        n.nodeChoice.accept(this);
        n.nodeToken1.accept(this);
    }

    /**
     * <PRE>
     * selectWithoutOrder -> SelectWithoutOrder()
     * </PRE>
     */
    public void visit(SubQuery n) throws Exception {
        n.selectWithoutOrder.accept(this);
    }

}

class FormatCommand {
    public static final int FORCE = 0;
    public static final int INDENT = 1;
    public static final int OUTDENT = 2;
    public static final int SPACE = 3;

    private int command;
    private int numCommands;

    FormatCommand(int command, int numCommands) {
        this.command = command;
        this.numCommands = numCommands;
    }

    public int getCommand() {
        return command;
    }

    public int getNumCommands() {
        return numCommands;
    }

    public void setCommand(int i) {
        command = i;
    }

    public void setNumCommands(int i) {
        numCommands = i;
    }
}

class TreeFormatterException extends RuntimeException {
    TreeFormatterException() {
        super();
    }

    TreeFormatterException(String s) {
        super(s);
    }
}
